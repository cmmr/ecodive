[{"path":[]},{"path":"https://cmmr.github.io/ecodive/CODE_OF_CONDUCT.html","id":"our-pledge","dir":"","previous_headings":"","what":"Our Pledge","title":"Contributor Covenant Code of Conduct","text":"members, contributors, leaders pledge make participation community harassment-free experience everyone, regardless age, body size, visible invisible disability, ethnicity, sex characteristics, gender identity expression, level experience, education, socio-economic status, nationality, personal appearance, race, caste, color, religion, sexual identity orientation. pledge act interact ways contribute open, welcoming, diverse, inclusive, healthy community.","code":""},{"path":"https://cmmr.github.io/ecodive/CODE_OF_CONDUCT.html","id":"our-standards","dir":"","previous_headings":"","what":"Our Standards","title":"Contributor Covenant Code of Conduct","text":"Examples behavior contributes positive environment community include: Demonstrating empathy kindness toward people respectful differing opinions, viewpoints, experiences Giving gracefully accepting constructive feedback Accepting responsibility apologizing affected mistakes, learning experience Focusing best just us individuals, overall community Examples unacceptable behavior include: use sexualized language imagery, sexual attention advances kind Trolling, insulting derogatory comments, personal political attacks Public private harassment Publishing others’ private information, physical email address, without explicit permission conduct reasonably considered inappropriate professional setting","code":""},{"path":"https://cmmr.github.io/ecodive/CODE_OF_CONDUCT.html","id":"enforcement-responsibilities","dir":"","previous_headings":"","what":"Enforcement Responsibilities","title":"Contributor Covenant Code of Conduct","text":"Community leaders responsible clarifying enforcing standards acceptable behavior take appropriate fair corrective action response behavior deem inappropriate, threatening, offensive, harmful. Community leaders right responsibility remove, edit, reject comments, commits, code, wiki edits, issues, contributions aligned Code Conduct, communicate reasons moderation decisions appropriate.","code":""},{"path":"https://cmmr.github.io/ecodive/CODE_OF_CONDUCT.html","id":"scope","dir":"","previous_headings":"","what":"Scope","title":"Contributor Covenant Code of Conduct","text":"Code Conduct applies within community spaces, also applies individual officially representing community public spaces. Examples representing community include using official e-mail address, posting via official social media account, acting appointed representative online offline event.","code":""},{"path":"https://cmmr.github.io/ecodive/CODE_OF_CONDUCT.html","id":"enforcement","dir":"","previous_headings":"","what":"Enforcement","title":"Contributor Covenant Code of Conduct","text":"Instances abusive, harassing, otherwise unacceptable behavior may reported community leaders responsible enforcement dansmith01@gmail.com. complaints reviewed investigated promptly fairly. community leaders obligated respect privacy security reporter incident.","code":""},{"path":"https://cmmr.github.io/ecodive/CODE_OF_CONDUCT.html","id":"enforcement-guidelines","dir":"","previous_headings":"","what":"Enforcement Guidelines","title":"Contributor Covenant Code of Conduct","text":"Community leaders follow Community Impact Guidelines determining consequences action deem violation Code Conduct:","code":""},{"path":"https://cmmr.github.io/ecodive/CODE_OF_CONDUCT.html","id":"id_1-correction","dir":"","previous_headings":"Enforcement Guidelines","what":"1. Correction","title":"Contributor Covenant Code of Conduct","text":"Community Impact: Use inappropriate language behavior deemed unprofessional unwelcome community. Consequence: private, written warning community leaders, providing clarity around nature violation explanation behavior inappropriate. public apology may requested.","code":""},{"path":"https://cmmr.github.io/ecodive/CODE_OF_CONDUCT.html","id":"id_2-warning","dir":"","previous_headings":"Enforcement Guidelines","what":"2. Warning","title":"Contributor Covenant Code of Conduct","text":"Community Impact: violation single incident series actions. Consequence: warning consequences continued behavior. interaction people involved, including unsolicited interaction enforcing Code Conduct, specified period time. includes avoiding interactions community spaces well external channels like social media. Violating terms may lead temporary permanent ban.","code":""},{"path":"https://cmmr.github.io/ecodive/CODE_OF_CONDUCT.html","id":"id_3-temporary-ban","dir":"","previous_headings":"Enforcement Guidelines","what":"3. Temporary Ban","title":"Contributor Covenant Code of Conduct","text":"Community Impact: serious violation community standards, including sustained inappropriate behavior. Consequence: temporary ban sort interaction public communication community specified period time. public private interaction people involved, including unsolicited interaction enforcing Code Conduct, allowed period. Violating terms may lead permanent ban.","code":""},{"path":"https://cmmr.github.io/ecodive/CODE_OF_CONDUCT.html","id":"id_4-permanent-ban","dir":"","previous_headings":"Enforcement Guidelines","what":"4. Permanent Ban","title":"Contributor Covenant Code of Conduct","text":"Community Impact: Demonstrating pattern violation community standards, including sustained inappropriate behavior, harassment individual, aggression toward disparagement classes individuals. Consequence: permanent ban sort public interaction within community.","code":""},{"path":"https://cmmr.github.io/ecodive/CODE_OF_CONDUCT.html","id":"attribution","dir":"","previous_headings":"","what":"Attribution","title":"Contributor Covenant Code of Conduct","text":"Code Conduct adapted Contributor Covenant, version 2.1, available https://www.contributor-covenant.org/version/2/1/code_of_conduct.html. Community Impact Guidelines inspired [Mozilla’s code conduct enforcement ladder][https://github.com/mozilla/inclusion]. answers common questions code conduct, see FAQ https://www.contributor-covenant.org/faq. Translations available https://www.contributor-covenant.org/translations.","code":""},{"path":"https://cmmr.github.io/ecodive/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2025 ecodive authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://cmmr.github.io/ecodive/articles/adiv.html","id":"input-matrix","dir":"Articles","previous_headings":"","what":"Input Matrix","title":"Alpha Diversity","text":"’ll use ex_counts feature table included ecodive. contains number observations bacterial genera sample. text , can substitute word ‘genera’ feature interest data.","code":"library(ecodive)  counts <- rarefy(ex_counts)  counts #>                   Saliva Gums Nose Stool #> Streptococcus        162  309    6     1 #> Bacteroides            2    2    0   341 #> Corynebacterium        0    0  171     1 #> Haemophilus          180   34    0     1 #> Propionibacterium      1    0   82     0 #> Staphylococcus         0    0   86     1"},{"path":"https://cmmr.github.io/ecodive/articles/adiv.html","id":"alpha-diversity","dir":"Articles","previous_headings":"","what":"Alpha Diversity","title":"Alpha Diversity","text":"Alpha diversity measure diversity within single sample. Depending metric, may measure richness /evenness.","code":""},{"path":"https://cmmr.github.io/ecodive/articles/adiv.html","id":"richness","dir":"Articles","previous_headings":"Alpha Diversity","what":"Richness","title":"Alpha Diversity","text":"Richness many genera present sample. simplest metric count non-zero genera. Chao1 metric takes step including unobserved low abundance genera, inferred using number times counts == 1 vs counts == 2.","code":"colSums(counts > 0) #> Saliva   Gums   Nose  Stool  #>      4      3      4      5 # Infers 8 unobserved genera chao1(c(1, 1, 1, 1, 2, 5, 5, 5)) #> [1] 16  # Infers less than 1 unobserved genera chao1(c(1, 2, 2, 2, 2, 5, 5, 5)) #> [1] 8.125  # Datasets without 1s and 2s give Inf or NaN chao1(counts) #> Saliva   Gums   Nose  Stool  #>    4.5    3.0    NaN    Inf"},{"path":"https://cmmr.github.io/ecodive/articles/adiv.html","id":"evenness","dir":"Articles","previous_headings":"Alpha Diversity","what":"Evenness","title":"Alpha Diversity","text":"Evenness equally distributed genera within sample. Simpson metric good measure evenness.","code":"# High Evenness simpson(c(20, 20, 20, 20, 20)) #> [1] 0.8  # Low Evenness simpson(c(100, 1, 1, 1, 1)) #> [1] 0.07507396  # Stool < Gums < Saliva < Nose sort(simpson(counts)) #>      Stool       Gums     Saliva       Nose  #> 0.02302037 0.18806133 0.50725478 0.63539593"},{"path":"https://cmmr.github.io/ecodive/articles/adiv.html","id":"richness-and-evenness","dir":"Articles","previous_headings":"Alpha Diversity","what":"Richness and Evenness","title":"Alpha Diversity","text":"Shannon diversity index weights richness evenness.","code":"# Low richness, Low evenness shannon(c(1, 1, 100)) #> [1] 0.1101001  # Low richness, High evenness shannon(c(100, 100, 100)) #> [1] 1.098612  # High richness, Low evenness shannon(1:100) #> [1] 4.416898  # High richness, High evenness shannon(rep(100, 100)) #> [1] 4.60517  # Stool < Gums < Saliva < Nose sort(shannon(counts)) #>      Stool       Gums     Saliva       Nose  #> 0.07927797 0.35692121 0.74119910 1.10615349"},{"path":"https://cmmr.github.io/ecodive/articles/adiv.html","id":"phylogenetic-alpha-diversity","dir":"Articles","previous_headings":"Alpha Diversity","what":"Phylogenetic Alpha Diversity","title":"Alpha Diversity","text":"Faith’s phylogenetic diversity index incorporates phylogenetic tree genera order measure many tree’s branches represented sample.","code":"# ex_tree: # #       +----------44---------- Haemophilus #   +-2-| #   |   +----------------68---------------- Bacteroides   #   |                       #   |             +---18---- Streptococcus #   |      +--12--|        #   |      |      +--11-- Staphylococcus #   +--11--|               #          |      +-----24----- Corynebacterium #          +--12--| #                 +--13-- Propionibacterium   faith(c(Propionibacterium = 1, Corynebacterium = 1), tree = ex_tree) #> [1] 60  faith(c(Propionibacterium = 1, Haemophilus = 1), tree = ex_tree) #> [1] 82  # Nose < Gums < Saliva < Stool sort(faith(counts, tree = ex_tree)) #>   Nose   Gums Saliva  Stool  #>    101    155    180    202"},{"path":"https://cmmr.github.io/ecodive/articles/bdiv.html","id":"input-matrix","dir":"Articles","previous_headings":"","what":"Input Matrix","title":"Beta Diversity","text":"’ll use ex_counts feature table included ecodive. contains number observations bacterial genera sample. text , can substitute word ‘genera’ feature interest data.","code":"library(ecodive)  counts <- rarefy(ex_counts)  counts #>                   Saliva Gums Nose Stool #> Streptococcus        162  309    6     1 #> Bacteroides            2    2    0   341 #> Corynebacterium        0    0  171     1 #> Haemophilus          180   34    0     1 #> Propionibacterium      1    0   82     0 #> Staphylococcus         0    0   86     1"},{"path":"https://cmmr.github.io/ecodive/articles/bdiv.html","id":"beta-diversity","dir":"Articles","previous_headings":"","what":"Beta Diversity","title":"Beta Diversity","text":"Beta diversity measure different two samples . Looking counts matrix , can easily see saliva gums similar, saliva stool different. different metrics described quantify difference, referred “distance” “dissimilarity” pair samples. distance 0 identical samples 1 completely different samples.","code":""},{"path":"https://cmmr.github.io/ecodive/articles/bdiv.html","id":"weighted-vs-unweighted","dir":"Articles","previous_headings":"Beta Diversity","what":"Weighted vs Unweighted","title":"Beta Diversity","text":"classic algorithms run weighted mode default. Specifying weighted = FALSE, e.g. canberra(counts, weighted = FALSE) switch unweighted mode. bray_curtis(), canberra(), euclidean(), gower(), jaccard(), kulczynski(), manhattan() UniFrac algorithms, unweighted_unifrac() unweighted others weighted. Unweighted: unweighted_unifrac() Weighted: weighted_unifrac(), normalized_unifrac(), generalized_unifrac(), variance_adjusted_unifrac()","code":""},{"path":"https://cmmr.github.io/ecodive/articles/bdiv.html","id":"partial-calculation","dir":"Articles","previous_headings":"","what":"Partial Calculation","title":"Beta Diversity","text":"default value pairs=NULL ecodive’s beta diversity functions results returned -vs-distance matrix completely filled . reference-vs-comparison, can use pairs parameter skip unwanted calculations save CPU time. larger dataset, noticeable improvement . pairs argument can : numeric vector, giving positions result calculate. logical vector, indicating whether calculate position result. function(,j) returns whether columns j compared. Therefore, following equivalent: ordering pairs follows pairings produced combn(). , instance, use gums reference sample:","code":"bray_curtis(counts) #>          Saliva      Gums      Nose #> Gums  0.4260870                     #> Nose  0.9797101 0.9826087           #> Stool 0.9884058 0.9884058 0.9913043 bray_curtis(counts, pairs = 1:3) #>          Saliva      Gums      Nose #> Gums  0.4260870                     #> Nose  0.9797101        NA           #> Stool 0.9884058        NA        NA bray_curtis(counts, pairs = 1:3) bray_curtis(counts, pairs = c(TRUE, TRUE, TRUE, FALSE, FALSE, FALSE)) bray_curtis(counts, pairs = function (i, j) i == 1) # Column index pairings combn(ncol(counts), 2) #>      [,1] [,2] [,3] [,4] [,5] [,6] #> [1,]    1    1    1    2    2    3 #> [2,]    2    3    4    3    4    4  # Sample name pairings combn(colnames(counts), 2) #>      [,1]     [,2]     [,3]     [,4]   [,5]    [,6]    #> [1,] \"Saliva\" \"Saliva\" \"Saliva\" \"Gums\" \"Gums\"  \"Nose\"  #> [2,] \"Gums\"   \"Nose\"   \"Stool\"  \"Nose\" \"Stool\" \"Stool\" my_combn <- combn(colnames(counts), 2) my_pairs <- my_combn[1,] == 'Gums' | my_combn[2,] == 'Gums'  my_pairs #> [1]  TRUE FALSE FALSE  TRUE  TRUE FALSE  bray_curtis(counts, pairs = my_pairs) #>          Saliva      Gums      Nose #> Gums  0.4260870                     #> Nose         NA 0.9826087           #> Stool        NA 0.9884058        NA"},{"path":"https://cmmr.github.io/ecodive/articles/bdiv_guide.html","id":"a-practical-guide-to-metric-selection-aligning-method-with-research-question","dir":"Articles","previous_headings":"","what":"A Practical Guide to Metric Selection:Aligning Method with Research Question","title":"Selecting a Beta Diversity Metric","text":"theoretical mathematical properties various beta diversity metrics provide foundation making informed choice. However, ultimate decision must driven specific research question nature dataset. vignette provides practical framework, including decision tree illustrative case studies, guide researchers scientific question appropriate metric.","code":""},{"path":"https://cmmr.github.io/ecodive/articles/bdiv_guide.html","id":"a-decision-tree-for-metric-selection","dir":"Articles","previous_headings":"A Practical Guide to Metric Selection:Aligning Method with Research Question","what":"A Decision Tree for Metric Selection","title":"Selecting a Beta Diversity Metric","text":"decision tree presents series questions help researcher systematically narrow field 37 metrics small, relevant subset.","code":""},{"path":"https://cmmr.github.io/ecodive/articles/bdiv_guide.html","id":"do-you-have-a-reliable-phylogenetic-tree-relating-your-taxa-e-g--asvsotus","dir":"Articles","previous_headings":"A Practical Guide to Metric Selection:Aligning Method with Research Question > A Decision Tree for Metric Selection","what":"1. Do you have a reliable phylogenetic tree relating your taxa (e.g., ASVs/OTUs)?","title":"Selecting a Beta Diversity Metric","text":"YES: analysis can likely leverage phylogenetic information. primarily interested presence/absence entire evolutionary lineages (e.g., detecting invasion novel phylum)? -> Start Unweighted UniFrac. primarily interested shifts abundance major, well-established lineages (e.g., Firmicutes/Bacteroidetes ratio)? -> Start Weighted UniFrac. interested robust analysis captures changes across rare, moderate, abundant lineages, unsure? -> Use Generalized UniFrac (α=0.5) powerful balanced primary choice. Consider using Variance-Adjusted Weighted UniFrac increased statistical power uneven sample sizes. : must use Non-Phylogenetic Metric. Proceed Question 2.","code":""},{"path":"https://cmmr.github.io/ecodive/articles/bdiv_guide.html","id":"is-your-data-compositional-i-e--relative-abundances-from-high-throughput-sequencing","dir":"Articles","previous_headings":"A Practical Guide to Metric Selection:Aligning Method with Research Question > A Decision Tree for Metric Selection","what":"2. Is your data compositional (i.e., relative abundances from high-throughput sequencing)?","title":"Selecting a Beta Diversity Metric","text":"YES: must account relative nature data. statistically rigorous approach use compositional metric. -> primary choice Aitchison distance. prepared handle zeros using pseudocount imputation method. choose use non-compositional metric, select one robust transformations proportions less sensitive extreme values. -> Good secondary choices include Hellinger, Jensen-Shannon Divergence, Horn-Morisita. Note fully address compositionality issue often better behaved Bray-Curtis Euclidean relative data. : data represents absolute counts measurements (e.g., microscopy quantitative PCR). Proceed Question 3.","code":""},{"path":"https://cmmr.github.io/ecodive/articles/bdiv_guide.html","id":"what-is-the-primary-ecological-signal-you-want-to-detect","dir":"Articles","previous_headings":"A Practical Guide to Metric Selection:Aligning Method with Research Question > A Decision Tree for Metric Selection","what":"3. What is the primary ecological signal you want to detect?","title":"Selecting a Beta Diversity Metric","text":"Presence/Absence specific taxa (Community Membership): interested species present, regardless abundance. -> Choose Qualitative (Binary) Metric. best options Jaccard (standard turnover) Dice-Sorensen (gives weight shared species). Shifts abundance taxa (Community Structure): interested species dominant abundances change. -> Choose Quantitative Metric. want robust, widely understood standard sensitive dominant taxa -> Use Bray-Curtis. data consists raw integer counts concerned sample size effects -> Use Morisita index. want -weight influence hyper-dominant species balanced view abundance changes -> Use Hellinger distance. concerned small changes rare taxa amplified -> Avoid Canberra distance.","code":""},{"path":"https://cmmr.github.io/ecodive/articles/bdiv_guide.html","id":"case-studies-matching-metrics-to-microbiome-research-questions","dir":"Articles","previous_headings":"A Practical Guide to Metric Selection:Aligning Method with Research Question","what":"Case Studies: Matching Metrics to Microbiome Research Questions","title":"Selecting a Beta Diversity Metric","text":"following case studies illustrate choice metric directly influences ability answer specific biological question.","code":""},{"path":"https://cmmr.github.io/ecodive/articles/bdiv_guide.html","id":"case-study-1-does-antibiotic-treatment-eliminate-specific-rare-potentially-pathogenic-taxa","dir":"Articles","previous_headings":"A Practical Guide to Metric Selection:Aligning Method with Research Question > Case Studies: Matching Metrics to Microbiome Research Questions","what":"Case Study 1: Does antibiotic treatment eliminate specific rare, potentially pathogenic taxa?","title":"Selecting a Beta Diversity Metric","text":"Research Question: question explicitly presence absence key organisms, likely rare overall community. massive shifts abundant, commensal bacteria secondary primary question pathogen eradication. Recommended Metric: Jaccard Unweighted UniFrac. Justification: quantitative metric like Bray-Curtis dominated large-scale disruption dominant taxa like Bacteroides Faecalibacterium. signal rare pathogen’s disappearance completely lost. contrast, qualitative metric like Jaccard treats disappearance pathogen (change 1 0) significant event, directly addressing research question. phylogenetic tree available, Unweighted UniFrac even better, capture loss entire evolutionary lineage, might biologically meaningful loss single ASV.","code":""},{"path":"https://cmmr.github.io/ecodive/articles/bdiv_guide.html","id":"case-study-2-how-does-a-high-fiber-vs--high-fat-diet-alter-the-overall-gut-microbiome-structure","dir":"Articles","previous_headings":"A Practical Guide to Metric Selection:Aligning Method with Research Question > Case Studies: Matching Metrics to Microbiome Research Questions","what":"Case Study 2: How does a high-fiber vs. high-fat diet alter the overall gut microbiome structure?","title":"Selecting a Beta Diversity Metric","text":"Research Question: question concerns broad, systemic shifts community’s metabolic capacity. expected signal change abundance major functional guilds—example, increase fiber-degrading Firmicutes decrease bile-acid-metabolizing bacteria. Recommended Metrics: Bray-Curtis Hellinger. Justification: question community structure abundance major players. Bray-Curtis excellent choice sensitive shifts dominant abundant taxa. Using Hellinger complementary metric robust strategy. Hellinger distance, using square-root transformation, -weight influence hyper-dominant taxa, providing slightly different potentially stable view overall structural change. metrics show significant difference diet groups, conclusion strong.","code":""},{"path":"https://cmmr.github.io/ecodive/articles/bdiv_guide.html","id":"case-study-3-comparing-gut-communities-with-vastly-different-dominant-phyla-e-g--bacteroidetes-dominant-vs--firmicutes-dominant-","dir":"Articles","previous_headings":"A Practical Guide to Metric Selection:Aligning Method with Research Question > Case Studies: Matching Metrics to Microbiome Research Questions","what":"Case Study 3: Comparing gut communities with vastly different dominant phyla (e.g., Bacteroidetes-dominant vs. Firmicutes-dominant).","title":"Selecting a Beta Diversity Metric","text":"Research Question: goal understand , subtle structural differences exist two community types, beyond obvious phylum-level dominance. relative proportions less abundant genera within Proteobacteria different, example? Recommended Metric: Aitchison distance. Justification: classic compositionality problem. Bray-Curtis analysis, massive difference abundance Firmicutes vs. Bacteroidetes create large distance two sample types variation rendered invisible. ordination plot likely show two tight, distant clusters, reveal nothing internal structure clusters. Aitchison distance, using log-ratios, effectively normalizes dominant phylum calculates distance based relative proportions taxa one another. allows researcher “see ” dominance effect investigate subtle structural differences directly address research question.","code":""},{"path":"https://cmmr.github.io/ecodive/articles/bdiv_guide.html","id":"case-study-4-are-the-microbial-communities-in-two-soil-types-different-due-to-the-loss-of-a-deep-evolutionary-lineage-or-due-to-shifts-within-the-same-major-families","dir":"Articles","previous_headings":"A Practical Guide to Metric Selection:Aligning Method with Research Question > Case Studies: Matching Metrics to Microbiome Research Questions","what":"Case Study 4: Are the microbial communities in two soil types different due to the loss of a deep evolutionary lineage or due to shifts within the same major families?","title":"Selecting a Beta Diversity Metric","text":"Research Question: question explicitly phylogenetic hierarchical. seeks distinguish two distinct types evolutionary change. Recommended Metrics: Generalized UniFrac (GUniFrac) varying alpha values, comparison Unweighted Weighted UniFrac. Justification: non-phylogenetic metric answer question. best approach use GUniFrac framework. researcher calculate distance matrix using multiple values α (e.g., 0, 0.5, 1). separation soil types significant α=0 (Unweighted UniFrac), suggests difference driven presence/absence entire clades (deep evolutionary change). separation strongest α=1 (Weighted UniFrac), suggests difference due abundance shifts within lineages present soils (shallow change). signal strongest α=0.5, points changes moderately abundant taxa key drivers, providing nuanced answer. Content generated Google Gemini. Verified formatted Daniel Smith. Sept. 5th, 2025.","code":""},{"path":[]},{"path":"https://cmmr.github.io/ecodive/articles/benchmark.html","id":"state-of-the-field","dir":"Articles","previous_headings":"Introduction","what":"State of the Field","title":"Benchmarks","text":"analysis provides comparative benchmark R packages designed calculating standard phylogenetic metrics alpha beta diversity. primary objective evaluate computational efficiency, focus processing speed memory allocation. Packages rely foundational libraries dependencies omitted study isolate performance core implementations.","code":""},{"path":"https://cmmr.github.io/ecodive/articles/benchmark.html","id":"methodology","dir":"Articles","previous_headings":"Introduction","what":"Methodology","title":"Benchmarks","text":"bench R package employed quantify computational runtime memory allocation diversity algorithms within 15 selected packages. benchmarks executed host system following hardware software configuration: Furthermore, bench::mark() function utilized verify outputs benchmarked expressions numerically equivalent, ensuring consistency comparability results.","code":"CPU: 6-Core Intel i5-9600K @ 3.70GHz RAM: 64.0 GB OS: Windows 11 Pro (64-bit, Version 24H2, Build 26100.4652)"},{"path":"https://cmmr.github.io/ecodive/articles/benchmark.html","id":"setup","dir":"Articles","previous_headings":"","what":"Setup","title":"Benchmarks","text":"Two standard datasets rbiom R package, hmp50 gems, selected evaluation. hmp50 dataset, includes 50 samples associated phylogenetic tree, used benchmark computationally intensive phylogenetic metrics, UniFrac Faith’s PD. traditional diversity metrics, significantly less demanding, larger gems dataset, comprising 1,006 samples, employed. account heterogeneous input output formats across 15 R packages, necessary data transformations performed. ensure benchmarks exclusively measured performance diversity calculations, data conversion steps executed outside timed code blocks whenever possible.","code":"install.packages('pak')  # Tools and Datasets for Benchmarking Report pak::pkg_install(pkg = c(   'bench', 'dplyr', 'ggplot2', 'ggrepel', 'rbiom' ))  # Diversity Metric Implementations pak::pkg_install(pkg = c(   'abdiv', 'adiv', 'ecodist', 'ecodive', 'entropart', 'GUniFrac',    'kasperskytte/ampvis2', 'labdsv', 'parallelDist', 'philentropy',    'phyloregion', 'phyloseq', 'picante', 'tabula', 'vegan' ))   # Software Versions  version$version.string #> [1] \"R version 4.5.1 (2025-06-13 ucrt)\"  data.frame(ver = sapply(FUN = packageDescription, fields = 'Version', c(   'bench', 'dplyr', 'ggplot2', 'ggrepel', 'rbiom',   'abdiv', 'adiv', 'ecodist', 'ecodive', 'entropart', 'GUniFrac',    'ampvis2', 'labdsv', 'parallelDist', 'philentropy',    'phyloregion', 'phyloseq', 'picante', 'tabula', 'vegan' ))) #>                     ver #> bench             1.1.4 #> dplyr             1.1.4 #> ggplot2           3.5.2 #> ggrepel           0.9.6 #> rbiom             2.2.1 #> abdiv             0.2.0 #> adiv              2.2.1 #> ecodist           2.1.3 #> ecodive           1.0.1 #> entropart        1.6-16 #> GUniFrac            1.8 #> ampvis2           2.8.9 #> labdsv            2.1-2 #> parallelDist      0.2.6 #> philentropy       0.9.0 #> phyloregion       1.0.9 #> phyloseq         1.52.0 #> picante           1.8.2 #> tabula            3.3.1 #> vegan             2.7-1  library(bench) library(ggplot2) library(ggrepel) library(dplyr)  (n_cpus <- ecodive::n_cpus()) #> [1] 6  # abdiv only accepts two samples at a time pairwise <- function (f, data, ...) {   pairs <- utils::combn(ncol(data), 2)   structure(     mapply(       FUN = function (i, j) f(data[,i], data[,j], ...),        i   = pairs[1,], j = pairs[2,] ),     class  = 'dist',     Labels = colnames(data),     Size   = ncol(data),     Diag   = FALSE,     Upper  = FALSE ) }   # Remove any extraneous attributes from dist objects, # allowing them to be compared with `all.equal()`. cleanup <- function (x) {   for (i in setdiff(names(attributes(x)), c('class', 'Labels', 'Size', 'Diag', 'Upper')))     attr(x, i) <- NULL   return (x) }   # HMP50 dataset has 50 Samples hmp50      <- rbiom::hmp50 hmp50_phy  <- rbiom::convert_to_phyloseq(hmp50) hmp50_mtx  <- rbiom::rescale_cols(as.matrix(hmp50)) hmp50_tmtx <- t(hmp50_mtx) hmp50_tree <- hmp50$tree   # GEMS dataset has 1006 Samples gems_mtx    <- rbiom::rescale_cols(as.matrix(rbiom::gems)) gems_tmtx   <- t(gems_mtx)"},{"path":"https://cmmr.github.io/ecodive/articles/benchmark.html","id":"unifrac","dir":"Articles","previous_headings":"","what":"UniFrac","title":"Benchmarks","text":"’ll compare time memory taken unweighted, weighted, weight normalized, generalized, variance adjusted UniFrac functions abdiv,ampvis2 ecodive, GUniFrac, phyloseq, phyloregion picante R packages. functions run 10 times time speed, 1 time analyze memory usage.  ecodive demonstrates substantial performance gains UniFrac, 2 3,900x faster using 50 - 32,000x less memory.","code":"## Unweighted UniFrac u_unifrac_res <- rbind(    local({     # cluster for phyloseq     cl <- parallel::makeCluster(n_cpus)     doParallel::registerDoParallel(cl)     on.exit(parallel::stopCluster(cl))          bench::mark(       iterations    = 10,       'abdiv'       = cleanup(pairwise(abdiv::unweighted_unifrac, hmp50_mtx, hmp50_tree)),       'ecodive'     = cleanup(ecodive::unweighted_unifrac(hmp50_mtx, hmp50_tree)),       'GUniFrac'    = cleanup(as.dist(GUniFrac::GUniFrac(hmp50_tmtx, hmp50_tree, alpha=1, verbose=FALSE)[[1]][,,2])),       'phyloregion' = cleanup(phyloregion::unifrac(hmp50_tmtx, hmp50_tree)),       'phyloseq'    = cleanup(phyloseq::UniFrac(hmp50_phy, weighted=FALSE, normalized=FALSE, parallel=TRUE)),       'picante'     = cleanup(picante::unifrac(hmp50_tmtx, hmp50_tree)) )   }),      # ampvis2 conflicts with phyloseq cluster, so run separately   bench::mark(     iterations = 10,     'ampvis2'  = {       cleanup(ampvis2:::dist.unifrac(hmp50_mtx, hmp50_tree, weighted=FALSE, normalise=FALSE, num_threads=n_cpus))       doParallel::stopImplicitCluster() } ) )  u_unifrac_res[,1:9] #> # A tibble: 5 × 13 #>   expression      min   median `itr/sec` mem_alloc `gc/sec` n_itr  n_gc total_time #>   <bch:expr> <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl> <int> <dbl>   <bch:tm> #> 1 abdiv        13.84s   14.38s    0.0676    20.1GB   1.87      10   277      2.46m #> 2 ecodive      5.19ms   5.31ms  184.       770.5KB   0         10     0    54.23ms #> 3 GUniFrac    77.89ms   80.4ms   11.7       92.1MB   1.17      10     1   858.32ms #> 4 phyloseq   292.07ms 327.01ms    2.49      49.9MB   0         10     0      4.02s #> 5 ampvis2       3.36s    3.44s    0.288     49.8MB   0.0320     9     1     31.29s  ggplot(u_unifrac_res, aes(x = median, y = mem_alloc)) +   geom_point() +   geom_label_repel(aes(label = as.character(expression))) +    labs(     title = 'Unweighted UniFrac Implementations',     subtitle = '50 sample all-vs-all benchmarking on six CPU cores',     x = 'Median Calculation Time (log scale; n=10)',      y = 'Memory Allocated\\n(log scale)' ) +   theme_bw()       ## Weighted UniFrac w_unifrac_res <- rbind(    local({     # cluster for phyloseq     cl <- parallel::makeCluster(n_cpus)     doParallel::registerDoParallel(cl)     on.exit(parallel::stopCluster(cl))          bench::mark(       iterations = 10,       'abdiv'    = cleanup(pairwise(abdiv::weighted_unifrac, hmp50_mtx, hmp50_tree)),       'ecodive'  = cleanup(ecodive::weighted_unifrac(hmp50_mtx, hmp50_tree)),       'phyloseq' = cleanup(phyloseq::UniFrac(hmp50_phy, weighted=TRUE, normalized=FALSE, parallel=TRUE)) )   }),      # ampvis2 conflicts with phyloseq cluster, so run separately   bench::mark(     iterations = 10,     'ampvis2'  = {       cleanup(ampvis2:::dist.unifrac(hmp50_mtx, hmp50_tree, weighted=TRUE, normalise=FALSE, num_threads=n_cpus))       doParallel::stopImplicitCluster() } ) )       ## Weighted Normalized UniFrac wn_unifrac_res <- rbind(    local({     # cluster for phyloseq     cl <- parallel::makeCluster(n_cpus)     doParallel::registerDoParallel(cl)     on.exit(parallel::stopCluster(cl))          bench::mark(       iterations = 10,       'abdiv'    = cleanup(pairwise(abdiv::weighted_normalized_unifrac, hmp50_mtx, hmp50_tree)),       'ecodive'  = cleanup(ecodive::normalized_unifrac(hmp50_mtx, hmp50_tree)),       'GUniFrac' = cleanup(as.dist(GUniFrac::GUniFrac(hmp50_tmtx, hmp50_tree, alpha=1, verbose=FALSE)[[1]][,,1])),       'phyloseq' = cleanup(phyloseq::UniFrac(hmp50_phy, weighted=TRUE, normalized=TRUE, parallel=TRUE)) )   }),      # ampvis2 conflicts with phyloseq cluster, so run separately   bench::mark(     iterations = 10,     'ampvis2'  = {       cleanup(ampvis2:::dist.unifrac(hmp50_mtx, hmp50_tree, weighted=TRUE, normalise=TRUE, num_threads=n_cpus))       doParallel::stopImplicitCluster() } ) )   ## Weighted Normalized UniFrac g_unifrac_res <- rbind(    local({     # cluster for phyloseq     cl <- parallel::makeCluster(n_cpus)     doParallel::registerDoParallel(cl)     on.exit(parallel::stopCluster(cl))          bench::mark(       iterations = 10,       'abdiv'    = cleanup(pairwise(abdiv::generalized_unifrac, hmp50_mtx, hmp50_tree, alpha=0.5)),       'ecodive'  = cleanup(ecodive::generalized_unifrac(hmp50_mtx, hmp50_tree, alpha=0.5)),       'GUniFrac' = cleanup(as.dist(GUniFrac::GUniFrac(hmp50_tmtx, hmp50_tree, alpha=0.5, verbose=FALSE)[[1]][,,1])) )   }) )   ## Variance Adjusted UniFrac va_unifrac_res <- rbind(    local({     # cluster for phyloseq     cl <- parallel::makeCluster(n_cpus)     doParallel::registerDoParallel(cl)     on.exit(parallel::stopCluster(cl))          bench::mark(       iterations = 10,       'abdiv'    = cleanup(pairwise(abdiv::variance_adjusted_unifrac, hmp50_mtx, hmp50_tree)),       'ecodive'  = cleanup(ecodive::variance_adjusted_unifrac(hmp50_mtx, hmp50_tree)) )   }) )   unifrac_res <- bind_rows(     mutate(u_unifrac_res,  `UniFrac Variant` = 'Unweighted'),     mutate(w_unifrac_res,  `UniFrac Variant` = 'Weighted'),     mutate(wn_unifrac_res, `UniFrac Variant` = 'Weighted Normalized'),     mutate(g_unifrac_res,  `UniFrac Variant` = 'Generalized'),     mutate(va_unifrac_res, `UniFrac Variant` = 'Variance Adjusted') ) %>%   mutate(Package = as.character(expression)) %>%   select(Package, `UniFrac Variant`, median, mem_alloc) %>%   arrange(Package)   print(unifrac_res, n = 21) #> # A tibble: 21 × 4 #>    Package     `UniFrac Variant`     median mem_alloc #>    <chr>       <chr>               <bch:tm> <bch:byt> #>  1 GUniFrac    Unweighted           77.43ms   113.4MB #>  2 GUniFrac    Weighted Normalized  78.29ms   92.15MB #>  3 GUniFrac    Generalized          75.25ms   92.15MB #>  4 abdiv       Unweighted            14.36s   20.05GB #>  5 abdiv       Weighted              13.61s   20.02GB #>  6 abdiv       Weighted Normalized   13.59s   20.03GB #>  7 abdiv       Generalized           13.72s   20.18GB #>  8 abdiv       Variance Adjusted     15.57s   24.46GB #>  9 ampvis2     Unweighted             3.31s   53.44MB #> 10 ampvis2     Weighted               3.25s    49.2MB #> 11 ampvis2     Weighted Normalized     3.3s   49.34MB #> 12 ecodive     Unweighted            3.94ms    1.01MB #> 13 ecodive     Weighted              3.46ms  779.72KB #> 14 ecodive     Weighted Normalized   3.82ms  779.73KB #> 15 ecodive     Generalized           5.59ms   799.3KB #> 16 ecodive     Variance Adjusted     4.12ms  779.73KB #> 17 phyloregion Unweighted            6.35ms  146.44MB #> 18 phyloseq    Unweighted           290.5ms   50.87MB #> 19 phyloseq    Weighted            287.27ms    49.4MB #> 20 phyloseq    Weighted Normalized 291.59ms   49.55MB #> 21 picante     Unweighted             2.43s    1.79GB   # How much faster and more memory efficient is ecodive? plyr::ddply(unifrac_res, as.name('UniFrac Variant'), function (x) {   x[['median']]    <- as.numeric(x[['median']])   x[['mem_alloc']] <- as.numeric(x[['mem_alloc']])   ecodive <- as.list(x[x[['Package']] == 'ecodive',])   x       <- x[x[['Package']] != 'ecodive',]   data.frame(     speed  = paste0(paste(collapse=' - ', round(range(x$median    / ecodive$median))), 'x'),     memory = paste0(paste(collapse=' - ', round(range(x$mem_alloc / ecodive$mem_alloc))), 'x') ) }) #>       UniFrac Variant        speed         memory #> 1         Generalized   13 - 2454x   118 - 26475x #> 2          Unweighted    2 - 3647x    50 - 20248x #> 3   Variance Adjusted 3776 - 3776x 32891 - 32891x #> 4            Weighted   83 - 3931x    65 - 26922x #> 5 Weighted Normalized   20 - 3555x    65 - 26934x   ggplot(unifrac_res, aes(x = median, y = mem_alloc)) +   geom_point(aes(shape = `UniFrac Variant`), size = 2) +   geom_label_repel(     data = ~subset(., `UniFrac Variant` == 'Unweighted'),     mapping = aes(label = Package),     box.padding = 0.4,     min.segment.length = Inf ) +    scale_shape(solid = FALSE) +    scale_y_log10(labels = scales::label_bytes()) +   labs(     title = 'UniFrac Implementations',     subtitle = 'All-vs-all 50 sample benchmarking on six CPU cores',     x = 'Median Calculation Time (log scale; n=10)',      y = 'Memory Allocated\\n(log scale; n=1)' ) +   theme_bw(base_size = 12) +   theme(axis.title.x = element_text(margin = margin(t = 10)))"},{"path":"https://cmmr.github.io/ecodive/articles/benchmark.html","id":"classic-beta-diversity","dir":"Articles","previous_headings":"","what":"Classic Beta Diversity","title":"Benchmarks","text":"’ll benchmark Bray-Curtis, Euclidean, Jaccard, Manhattan classic beta diversity algorithms abdiv, ecodive, ecodist, vegan R packages. functions run 10 times time speed, 1 time analyze memory usage.  ecodive 6 2,300x faster uses 1 1,800x less memory.","code":"bray_curtis_res <- bench::mark(   iterations = 10,   'abdiv'        = cleanup(pairwise(abdiv::bray_curtis, gems_mtx)),   'ecodist'      = cleanup(ecodist::bcdist(gems_tmtx)),   'ecodive'      = cleanup(ecodive::bray(gems_mtx, rescale = FALSE)),   'labdsv'       = cleanup(labdsv::dsvdis(gems_tmtx, 'bray/curtis')),   'parallelDist' = cleanup(parallelDist::parallelDist(gems_tmtx, 'bray')),   'philentropy'  = cleanup(philentropy::distance(gems_tmtx, 'sorensen', test.na = FALSE, use.row.names = TRUE, as.dist.obj = TRUE, mute.message = TRUE)),   'tabula'       = cleanup(1 - pairwise(tabula::index_bray, gems_mtx)),   'vegan'        = cleanup(vegan::vegdist(gems_tmtx, 'bray')) )  jaccard_res <- bench::mark(   iterations = 10,   'abdiv'        = cleanup(pairwise(abdiv::jaccard, gems_mtx)),   'ecodist'      = cleanup(ecodist::distance(gems_tmtx, 'jaccard')),   'ecodive'      = cleanup(ecodive::jaccard(gems_mtx, rescale = FALSE)),   'parallelDist' = cleanup(parallelDist::parallelDist(gems_tmtx, 'binary')),   'philentropy'  = cleanup(philentropy::distance(gems_tmtx > 0, 'jaccard', test.na = FALSE, use.row.names = TRUE, as.dist.obj = TRUE, mute.message = TRUE)),   'phyloregion'  = cleanup(phyloregion::beta_diss(gems_tmtx, 'jaccard')$beta.jac),   'stats'        = cleanup(stats::dist(gems_tmtx, 'binary')),   'vegan'        = cleanup(vegan::vegdist(gems_tmtx, 'jaccard', binary = TRUE)) )  manhattan_res <- bench::mark(   iterations = 10,   'abdiv'        = cleanup(pairwise(abdiv::manhattan, gems_mtx)),   'ecodist'      = cleanup(ecodist::distance(gems_tmtx, 'manhattan')),   'ecodive'      = cleanup(ecodive::manhattan(gems_mtx, rescale = FALSE)),   'parallelDist' = cleanup(parallelDist::parallelDist(gems_tmtx, 'manhattan')),   'philentropy'  = cleanup(philentropy::distance(gems_tmtx, 'manhattan', test.na = FALSE, use.row.names = TRUE, as.dist.obj = TRUE, mute.message = TRUE)),   'stats'        = cleanup(stats::dist(gems_tmtx, 'manhattan')),   'vegan'        = cleanup(vegan::vegdist(gems_tmtx, 'manhattan')) )  euclidean_res <- bench::mark(   iterations = 10,   'abdiv'        = cleanup(pairwise(abdiv::euclidean, gems_mtx)),   'ecodist'      = cleanup(ecodist::distance(gems_tmtx, 'euclidean')),   'ecodive'      = cleanup(ecodive::euclidean(gems_mtx, rescale = FALSE)),   'parallelDist' = cleanup(parallelDist::parallelDist(gems_tmtx, 'euclidean')),   'philentropy'  = cleanup(philentropy::distance(gems_tmtx, 'euclidean', test.na = FALSE, use.row.names = TRUE, as.dist.obj = TRUE, mute.message = TRUE)),   'stats'        = cleanup(stats::dist(gems_tmtx, 'euclidean')),   'vegan'        = cleanup(vegan::vegdist(gems_tmtx, 'euclidean')) )  bdiv_res <- bind_rows(     mutate(bray_curtis_res, Metric = 'Bray-Curtis'),     # mutate(jaccard_res,     Metric = 'Jaccard'),     # mutate(manhattan_res,   Metric = 'Manhattan'),     # mutate(euclidean_res,   Metric = 'Euclidean')      ) %>%   mutate(Package = as.character(expression)) %>%   select(Package, Metric, median, mem_alloc) %>%   arrange(Package)   print(bdiv_res, n = 30) #> # A tibble: 30 × 4 #>    Package      Metric        median mem_alloc #>    <chr>        <chr>       <bch:tm> <bch:byt> #>  1 abdiv        Bray-Curtis    11.5s   20.43GB #>  2 abdiv        Jaccard        1.83m   24.89GB #>  3 abdiv        Manhattan       2.9m   17.52GB #>  4 abdiv        Euclidean      2.35m   17.52GB #>  5 ecodist      Bray-Curtis  482.5ms   29.25MB #>  6 ecodist      Jaccard        3.04m   47.89GB #>  7 ecodist      Manhattan      2.14m    21.8GB #>  8 ecodist      Euclidean      2.07m    21.8GB #>  9 ecodive      Bray-Curtis 115.72ms   20.41MB #> 10 ecodive      Jaccard      100.5ms   14.52MB #> 11 ecodive      Manhattan   156.29ms   20.42MB #> 12 ecodive      Euclidean   143.38ms   20.42MB #> 13 labdsv       Bray-Curtis    1.13s   63.94MB #> 14 parallelDist Bray-Curtis 258.71ms    4.02MB #> 15 parallelDist Jaccard     317.93ms    3.86MB #> 16 parallelDist Manhattan   163.51ms    3.86MB #> 17 parallelDist Euclidean   158.62ms    3.86MB #> 18 philentropy  Bray-Curtis    11.2s   14.65GB #> 19 philentropy  Jaccard        1.89m    17.6GB #> 20 philentropy  Manhattan      2.18m   14.65GB #> 21 philentropy  Euclidean       2.3m   14.65GB #> 22 phyloregion  Jaccard     141.15ms  193.92MB #> 23 stats        Jaccard        3.02s    3.86MB #> 24 stats        Manhattan      2.21s    3.86MB #> 25 stats        Euclidean      2.22s    3.86MB #> 26 tabula       Bray-Curtis   21.77s   20.44GB #> 27 vegan        Bray-Curtis    2.63s    12.6MB #> 28 vegan        Jaccard        1.95s   59.69MB #> 29 vegan        Manhattan      1.61s    9.64MB #> 30 vegan        Euclidean      1.63s    9.64MB   # How much faster and more memory efficient is ecodive? plyr::ddply(bdiv_res, 'Metric', function (x) {   x[['median']]    <- as.numeric(x[['median']])   x[['mem_alloc']] <- as.numeric(x[['mem_alloc']])   ecodive <- as.list(x[x[['Package']] == 'ecodive',])   x       <- x[x[['Package']] != 'ecodive',]   data.frame(     speed  = paste0(paste(collapse=' - ', round(range(x$median    / ecodive$median))), 'x'),     memory = paste0(paste(collapse=' - ', round(range(x$mem_alloc / ecodive$mem_alloc))), 'x') ) }) #>        Metric       speed     memory #> 1 Bray-Curtis    6 - 680x   1 - 571x #> 2   Euclidean  24 - 2825x   1 - 849x #> 3     Jaccard  25 - 3359x  1 - 1865x #> 4   Manhattan  23 - 2340x   1 - 849x   ggplot(bdiv_res, aes(x = median, y = mem_alloc)) +   geom_point() +   facet_wrap('Metric', scales = 'fixed') +    geom_label_repel(aes(label = Package), direction = 'y') +    bench::scale_x_bench_time(limits = c(.05, 500), breaks = c(.1, 1, 10, 60, 300)) +   scale_y_log10(limits = 10^c(6,11.5), labels = scales::label_bytes()) +   labs(     title = 'Classic Beta Diversity Implementations',     subtitle = 'All-vs-all 1,006 sample benchmarking on six CPU cores',     x = 'Median Calculation Time (log scale; n=10)',      y = 'Memory Allocated\\n(log scale; n=1)' ) +   theme_bw(base_size = 12) +   theme(axis.title.x = element_text(margin = margin(t = 10)))"},{"path":"https://cmmr.github.io/ecodive/articles/benchmark.html","id":"alpha-diversity","dir":"Articles","previous_headings":"","what":"Alpha Diversity","title":"Benchmarks","text":"Last, ’ll compare Shannon, Simpson, Faith alpha diversity implementations abdiv, ecodive, entropart, phyloregion, vegan R packages. Faith’s phylogenetic diversity metric run 50 samples, Shannon Simpson metrics run 1,006 samples.  ecodive 2 43,000x faster uses 1 33,000x less memory.","code":"shannon_res <- bench::mark(   iterations  = 10,   'abdiv'     = apply(gems_mtx, 2L, abdiv::shannon),   'adiv'      = adiv::speciesdiv(gems_tmtx, 'Shannon')[,1],   'ecodive'   = ecodive::shannon(gems_mtx),   'entropart' = apply(gems_mtx, 2L, entropart::Shannon, CheckArguments = FALSE),   'vegan'     = vegan::diversity(gems_tmtx, 'shannon') )  simpson_res <- bench::mark(   iterations  = 10,   check       = FALSE, # entropart is off by a small bit   'abdiv'     = apply(gems_mtx, 2L, abdiv::simpson),   'adiv'      = adiv::speciesdiv(gems_tmtx, 'GiniSimpson')[,1],   'ecodive'   = ecodive::simpson(gems_mtx),   'entropart' = apply(gems_mtx, 2L, entropart::Simpson, CheckArguments = FALSE),   'vegan'     = vegan::diversity(gems_tmtx, 'simpson') )  faith_res <- bench::mark(   iterations    = 10,   check         = FALSE, # entropart has incorrect output on non-ultrametric tree   'abdiv'       = apply(hmp50_mtx, 2L, abdiv::faith_pd, hmp50_tree),   'adiv'        = apply(hmp50_mtx, 2L, \\(x) adiv::EH(hmp50_tree, rownames(hmp50_mtx)[x > 0])),   'ecodive'     = ecodive::faith(hmp50_mtx, hmp50_tree),   'entropart'   = apply(hmp50_mtx, 2L, entropart::PDFD, hmp50_tree, CheckArguments = FALSE),   'phyloregion' = phyloregion::PD(hmp50_tmtx, hmp50_tree) )  adiv_res <- bind_rows(     mutate(shannon_res, Metric = 'Shannon x 1006'),     mutate(simpson_res, Metric = 'Simpson x 1006'),     mutate(faith_res,   Metric = 'Faith PD x 50') ) %>%   mutate(Package = as.character(expression)) %>%   select(Package, Metric, median, mem_alloc) %>%   arrange(Package)   adiv_res #> # A tibble: 15 × 4 #>    Package     Metric           median mem_alloc #>    <chr>       <chr>          <bch:tm> <bch:byt> #>  1 abdiv       Shannon x 1006  67.06ms    89.5MB #>  2 abdiv       Simpson x 1006  14.77ms   26.75MB #>  3 abdiv       Faith PD x 50  490.64ms  651.37MB #>  4 adiv        Shannon x 1006  40.42ms   128.1MB #>  5 adiv        Simpson x 1006  34.19ms   53.18MB #>  6 adiv        Faith PD x 50     1.78s  488.78MB #>  7 ecodive     Shannon x 1006   7.53ms   14.74MB #>  8 ecodive     Simpson x 1006   7.48ms   14.72MB #>  9 ecodive     Faith PD x 50  684.95µs  749.23KB #> 10 entropart   Shannon x 1006    1.34s   296.1MB #> 11 entropart   Simpson x 1006  25.07ms   21.48MB #> 12 entropart   Faith PD x 50    29.48s   23.95GB #> 13 phyloregion Faith PD x 50    2.91ms    1.93MB #> 14 vegan       Shannon x 1006   59.3ms    62.2MB #> 15 vegan       Simpson x 1006  39.69ms   56.27MB   # How much faster and more memory efficient is ecodive? plyr::ddply(adiv_res, 'Metric', function (x) {   x[['median']]    <- as.numeric(x[['median']])   x[['mem_alloc']] <- as.numeric(x[['mem_alloc']])   ecodive <- as.list(x[x[['Package']] == 'ecodive',])   x       <- x[x[['Package']] != 'ecodive',]   data.frame(     speed  = paste0(paste(collapse=' - ', round(range(x$median    / ecodive$median))), 'x'),     memory = paste0(paste(collapse=' - ', round(range(x$mem_alloc / ecodive$mem_alloc))), 'x') ) }) #>           Metric      speed     memory #> 1  Faith PD x 50 4 - 43038x 3 - 33517x #> 2 Shannon x 1006   5 - 178x    4 - 20x #> 3 Simpson x 1006     2 - 5x     1 - 4x   ggplot(adiv_res, aes(x = median, y = mem_alloc)) +   geom_point(size = 2) +   geom_label_repel(aes(label = Package)) +    facet_wrap('Metric', nrow = 1, scales = 'free') +    scale_y_log10(labels = scales::label_bytes()) +   labs(     title = 'Alpha Diversity Implementations',     subtitle = '50 or 1,006 sample benchmarking on six CPU cores',     x = 'Median Calculation Time (log scale; n=10)',      y = 'Memory Allocated\\n(log scale; n=1)' ) +   theme_bw(base_size = 12) +   theme(axis.title.x = element_text(margin = margin(t = 10)))"},{"path":"https://cmmr.github.io/ecodive/articles/ecodive.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Introduction to ecodive","text":"Ecodive calculates ecological diversity metrics. Alpha diversity metrics provide insight single sample’s diversity, whereas beta diversity metrics indicate different pair samples . guide, ’ll use ex_counts dataset included ecodive. ex_counts feature table enumerates many times bacterial genera observed different body sites. example, ‘features’ feature table genera. However, dataset can use whatever feature makes sense - species, OTUs, ASVs, even something completely unrelated ecology. metrics implemented natively ecodive highly optimized speed memory. However, provide broadest range metrics interface, ecodive also provides wrappers around functions vegan tabula R packages. use , vegan /tabula must installed separately.","code":"library(ecodive)  ex_counts #>                   Saliva Gums Nose Stool #> Streptococcus        162  793   22     1 #> Bacteroides            2    4    2   611 #> Corynebacterium        0    0  498     1 #> Haemophilus          180   87    2     1 #> Propionibacterium      1    1  251     0 #> Staphylococcus         0    1  236     1"},{"path":"https://cmmr.github.io/ecodive/articles/ecodive.html","id":"alpha-diversity","dir":"Articles","previous_headings":"","what":"Alpha Diversity","title":"Introduction to ecodive","text":"Alpha diversity metrics describe many different genera present sample. Depending metric, can take account number unique genera (richness), evenly population split among genera (evenness), distantly related genera (phylogenetic diversity). Classic metrics: chao1(), shannon(), simpson(), inv_simpson() Classic metrics (via vegan): fisher(), ace() Classic metrics (via tabula): brillouin(), mcintosh(), berger(), margalef(), menhinick(), squares() Phylogenetic metrics: faith() reading: vignette('adiv')","code":""},{"path":"https://cmmr.github.io/ecodive/articles/ecodive.html","id":"beta-diversity","dir":"Articles","previous_headings":"","what":"Beta Diversity","title":"Introduction to ecodive","text":"Beta diversity metrics describe different two samples , based genera observed . Also known “distance” “dissimilarity”. UniFrac metrics incorporate phylogenetic tree calculation. Classic metrics: bray_curtis(), canberra(), euclidean(), gower(), jaccard(), kulczynski(), manhattan() Classic metrics (via vegan): clark(), alt_gower(), morisita(), horn(), mountford(), raup(), binomial(), cao(), mahalanobis(), chisq(), chord(), hellinger(), aitchison(), robust_aitchison() Phylogenetic metrics: unweighted_unifrac(), weighted_unifrac(), normalized_unifrac(), generalized_unifrac(), variance_adjusted_unifrac() reading: vignette('bdiv') vignette('unifrac').","code":""},{"path":[]},{"path":"https://cmmr.github.io/ecodive/articles/ecodive.html","id":"rarefaction","dir":"Articles","previous_headings":"Example","what":"Rarefaction","title":"Introduction to ecodive","text":"ex_counts feature table 345 saliva observations, nose 1011 observations. unequal sampling depth can cause systematic biases. Specifically, rare genera observed often samples greater sampling depths, thereby artificially inflating observed richness. first step rarefy ex_counts samples number observations. Rarefying randomly removes observations samples observations.","code":"colSums(ex_counts) #> Saliva   Gums   Nose  Stool  #>    345    886   1011    615   counts <- rarefy(ex_counts)  colSums(counts) #> Saliva   Gums   Nose  Stool  #>    345    345    345    345   counts #>                   Saliva Gums Nose Stool #> Streptococcus        162  309    6     1 #> Bacteroides            2    2    0   341 #> Corynebacterium        0    0  171     1 #> Haemophilus          180   34    0     1 #> Propionibacterium      1    0   82     0 #> Staphylococcus         0    0   86     1"},{"path":"https://cmmr.github.io/ecodive/articles/ecodive.html","id":"classic-metrics","dir":"Articles","previous_headings":"Example","what":"Classic Metrics","title":"Introduction to ecodive","text":"alpha beta diversity metrics around 50+ years don’t require phylogenetic tree. beta diversity functions can take weighted = FALSE argument use presence/absence information instead relative abundances.","code":"## Alpha Diversity -------------------  shannon(counts) #>     Saliva       Gums       Nose      Stool  #> 0.74119910 0.35692121 1.10615349 0.07927797    ## Beta Diversity --------------------  bray_curtis(counts) #>          Saliva      Gums      Nose #> Gums  0.4260870                     #> Nose  0.9797101 0.9826087           #> Stool 0.9884058 0.9884058 0.9913043  bray_curtis(counts, weighted = FALSE) #>          Saliva      Gums      Nose #> Gums  0.1428571                     #> Nose  0.5000000 0.7142857           #> Stool 0.3333333 0.2500000 0.3333333"},{"path":"https://cmmr.github.io/ecodive/articles/ecodive.html","id":"phylogenetic-metrics","dir":"Articles","previous_headings":"Example","what":"Phylogenetic Metrics","title":"Introduction to ecodive","text":"phylogenetic tree enables alpha beta diversity metrics take account evolutionary relatedness observed genera, generally giving higher diversity values samples distantly related genera. Faith (alpha diversity) UniFrac (beta diversity) examples phylogenetic metrics. ex_tree object included ecodive provides phylogenetic tree genera ex_counts. datasets, can use ecodive’s read_tree() function import phylogenetic tree newick formatted string file.","code":"## Alpha Diversity -------------------  faith(counts, tree = ex_tree) #> Saliva   Gums   Nose  Stool  #>    180    155    101    202    ## Beta Diversity --------------------  normalized_unifrac(counts, tree = ex_tree) #>          Saliva      Gums      Nose #> Gums  0.4328662                     #> Nose  0.7928701 0.6767840           #> Stool 0.9677535 0.9829736 0.9936121"},{"path":"https://cmmr.github.io/ecodive/articles/ecodive.html","id":"distance-matrices","dir":"Articles","previous_headings":"Example","what":"Distance Matrices","title":"Introduction to ecodive","text":"Beta diversity functions return dist object. can convert standard R matrix .matrix() function.","code":"dm <- bray_curtis(counts, weighted = FALSE) dm #>          Saliva      Gums      Nose #> Gums  0.1428571                     #> Nose  0.5000000 0.7142857           #> Stool 0.3333333 0.2500000 0.3333333  mtx <- as.matrix(dm) mtx #>           Saliva      Gums      Nose     Stool #> Saliva 0.0000000 0.1428571 0.5000000 0.3333333 #> Gums   0.1428571 0.0000000 0.7142857 0.2500000 #> Nose   0.5000000 0.7142857 0.0000000 0.3333333 #> Stool  0.3333333 0.2500000 0.3333333 0.0000000  mtx['Saliva', 'Nose'] #> [1] 0.5"},{"path":"https://cmmr.github.io/ecodive/articles/unifrac.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"UniFrac Calculations","text":"different UniFrac algorithms listed , along examples calculating .","code":""},{"path":"https://cmmr.github.io/ecodive/articles/unifrac.html","id":"input-data","dir":"Articles","previous_headings":"","what":"Input Data","title":"UniFrac Calculations","text":"numeric matrix two samples five species. phylogenetic tree five species.","code":""},{"path":"https://cmmr.github.io/ecodive/articles/unifrac.html","id":"definitions","dir":"Articles","previous_headings":"","what":"Definitions","title":"UniFrac Calculations","text":"branch indices (green circles) used ordering L, , B arrays. Values L drawn input phylogenetic tree. Values B total number species observations descending branch; Sample_A, B Sample_B.","code":""},{"path":"https://cmmr.github.io/ecodive/articles/unifrac.html","id":"unweighted","dir":"Articles","previous_headings":"","what":"Unweighted","title":"UniFrac Calculations","text":"Lozupone et al, 2005: Unweighted UniFrac R Package ecodive: unweighted_unifrac() R Package abdiv: unweighted_unifrac() R Package phyloseq: UniFrac(weighted=FALSE) qiime2 qiime diversity beta-phylogenetic --p-metric unweighted_unifrac mothur: unifrac.unweighted() First, transform B presence (1) absence (0) indicators. \\begin{align*}  &= \\{9, 0, 0, 0, 9, 6, 3, 3\\} \\\\ ' &= \\{1, 0, 0, 0, 1, 1, 1, 1\\} \\end{align*} \\begin{align*} B  &= \\{7, 5, 1, 4, 2, 8, 8, 0\\} \\\\ B' &= \\{1, 1, 1, 1, 1, 1, 1, 0\\} \\end{align*} apply formula: \\begin{align*} U &= \\displaystyle \\frac{\\sum_{= 1}^{n} L_i(|'_i - B'_i|)}{\\sum_{= 1}^{n} L_i(max('_i,B'_i))}  \\\\ \\\\ U &= \\displaystyle \\frac{L_1(|'_1-B'_1|) + L_2(|'_2-B'_2|) + \\cdots + L_n(|'_n-B'_n|)}{L_1(max('_1,B'_1)) + L_2(max('_2,B'_2)) + \\cdots + L_n(max('_n,B'_n))}  \\\\ \\\\ U &= \\displaystyle \\frac{0.2(|1-1|) + 0.4(|0-1|) + \\cdots + 0.3(|1-0|)}{0.2(max(1,1)) + 0.4(max(0,1)) + \\cdots + 0.3(max(1,0))}  \\\\ \\\\ U &= \\displaystyle \\frac{0.2(0) + 0.4(1) + 0.8(1) + 0.5(1) + 0.9(0) + 0.6(0) + 0.7(0) + 0.3(1)}{0.2(1) + 0.4(1) + 0.8(1) + 0.5(1) + 0.9(1) + 0.6(1) + 0.7(1) + 0.3(1)}  \\\\ \\\\ U &= \\displaystyle \\frac{0.4 + 0.8 + 0.5 + 0.3}{0.2 + 0.4 + 0.8 + 0.5 + 0.9 + 0.6 + 0.7 + 0.3}  \\\\ \\\\ U &= \\displaystyle \\frac{2}{4.4}  \\\\ \\\\ U &= 0.4545455 \\end{align*}","code":""},{"path":"https://cmmr.github.io/ecodive/articles/unifrac.html","id":"weighted","dir":"Articles","previous_headings":"","what":"Weighted","title":"UniFrac Calculations","text":"Lozupone et al, 2007: Raw Weighted UniFrac R Package ecodive: weighted_unifrac() R Package abdiv: weighted_unifrac() R Package phyloseq: UniFrac(weighted=TRUE, normalized=FALSE) qiime2 qiime diversity beta-phylogenetic --p-metric weighted_unifrac \\begin{align*} W &= \\sum_{= 1}^{n} L_i|\\frac{A_i}{A_T} - \\frac{B_i}{B_T}|  \\\\ \\\\ W &= L_1|\\frac{A_1}{A_T} - \\frac{B_1}{B_T}| + L_2|\\frac{A_2}{A_T} - \\frac{B_2}{B_T}| + \\cdots + L_n|\\frac{A_n}{A_T} - \\frac{B_n}{B_T}|  \\\\ \\\\ W &= 0.2|\\frac{9}{15} - \\frac{7}{15}| + 0.4|\\frac{0}{15} - \\frac{5}{15}| + \\cdots + 0.3|\\frac{3}{15} - \\frac{0}{15}|  \\\\ \\\\ W &= 0.02\\overline{6} + 0.1\\overline{3} + 0.05\\overline{3} + 0.1\\overline{3} + 0.42 + 0.08 + 0.2\\overline{3} + 0.06  \\\\ \\\\ W &= 1.14 \\end{align*}","code":""},{"path":"https://cmmr.github.io/ecodive/articles/unifrac.html","id":"normalized","dir":"Articles","previous_headings":"","what":"Normalized","title":"UniFrac Calculations","text":"Lozupone et al, 2007: Normalized Weighted UniFrac R Package ecodive: normalized_unifrac() R Package abdiv: weighted_normalized_unifrac() R Package phyloseq: UniFrac(weighted=TRUE, normalized=TRUE) qiime2 qiime diversity beta-phylogenetic --p-metric weighted_normalized_unifrac mothur: unifrac.weighted() \\begin{align*}  N &= \\displaystyle \\frac   {\\sum_{= 1}^{n} L_i|\\frac{A_i}{A_T} - \\frac{B_i}{B_T}|}   {\\sum_{= 1}^{n} L_i(\\frac{A_i}{A_T} + \\frac{B_i}{B_T})}   \\\\ \\\\    N &= \\displaystyle \\frac   {L_1|\\frac{A_1}{A_T} - \\frac{B_1}{B_T}| + L_2|\\frac{A_2}{A_T} - \\frac{B_2}{B_T}| + \\cdots + L_n|\\frac{A_n}{A_T} - \\frac{B_n}{B_T}|}   {L_1(\\frac{A_1}{A_T} + \\frac{B_1}{B_T}) + L_2(\\frac{A_2}{A_T} + \\frac{B_2}{B_T}) + \\cdots + L_n(\\frac{A_n}{A_T} + \\frac{B_n}{B_T})}   \\\\ \\\\    N &= \\displaystyle \\frac   {0.2|\\frac{9}{15} - \\frac{7}{15}| + 0.4|\\frac{0}{15} - \\frac{5}{15}| + \\cdots + 0.3|\\frac{3}{15} - \\frac{0}{15}|}   {0.2(\\frac{9}{15} + \\frac{7}{15}) + 0.4(\\frac{0}{15} + \\frac{5}{15}) + \\cdots + 0.3(\\frac{3}{15} + \\frac{0}{15})}   \\\\ \\\\    N &= \\displaystyle \\frac   {0.02\\overline{6} + 0.1\\overline{3} + 0.05\\overline{3} + 0.1\\overline{3} + 0.42 + 0.08 + 0.2\\overline{3} + 0.06}   {0.21\\overline{3} + 0.1\\overline{3} + 0.05\\overline{3} + 0.1\\overline{3} + 0.66 + 0.56 + 0.51\\overline{3} + 0.06}   \\\\ \\\\    N &= \\displaystyle \\frac{1.14}{2.326667}  \\\\ \\\\ N &= 0.4899713 \\end{align*}","code":""},{"path":"https://cmmr.github.io/ecodive/articles/unifrac.html","id":"generalized","dir":"Articles","previous_headings":"","what":"Generalized","title":"UniFrac Calculations","text":"Chen et al. 2012: Generalized UniFrac R Package ecodive: generalized_unifrac(alpha = 0.5) R Package abdiv: generalized_unifrac(alpha = 0.5) R Package GUniFrac: GUniFrac(alpha = 0.5) qiime2 qiime diversity beta-phylogenetic --p-metric generalized_unifrac -0.5 \\begin{align*}  G &= \\displaystyle \\frac   {\\sum_{= 1}^{n} L_i(\\frac{A_i}{A_T} + \\frac{B_i}{B_T})^{\\alpha}     |\\displaystyle \\frac       {\\frac{A_i}{A_T} - \\frac{B_i}{B_T}}       {\\frac{A_i}{A_T} + \\frac{B_i}{B_T}} |}   {\\sum_{= 1}^{n} L_i(\\frac{A_i}{A_T} + \\frac{B_i}{B_T})^{\\alpha}}  \\\\ \\\\  G &= \\displaystyle \\frac   {     L_1(\\frac{A_1}{A_T} + \\frac{B_1}{B_T})^{0.5}       |\\displaystyle \\frac         {\\frac{A_1}{A_T} - \\frac{B_1}{B_T}}         {\\frac{A_1}{A_T} + \\frac{B_1}{B_T}}| +     \\cdots +     L_n(\\frac{A_n}{A_T} + \\frac{B_n}{B_T})^{0.5}       |\\displaystyle \\frac         {\\frac{A_n}{A_T} - \\frac{B_n}{B_T}}         {\\frac{A_n}{A_T} + \\frac{B_n}{B_T}}|   }{     L_1(\\frac{A_1}{A_T} + \\frac{B_1}{B_T})^{0.5} +     \\cdots +     L_n(\\frac{A_n}{A_T} + \\frac{B_n}{B_T})^{0.5}   }     \\\\ \\\\  G &= \\displaystyle \\frac   {     0.2(\\frac{9}{15} + \\frac{7}{15})^{0.5}       |\\displaystyle \\frac         {\\frac{9}{15} - \\frac{7}{15}}         {\\frac{9}{15} + \\frac{7}{15}}| +     \\cdots +     0.3(\\frac{3}{15} + \\frac{0}{15})^{0.5}       |\\displaystyle \\frac         {\\frac{3}{15} - \\frac{0}{15}}         {\\frac{3}{15} + \\frac{0}{15}}|   }{     0.2(\\frac{9}{15} + \\frac{7}{15})^{0.5} +     \\cdots +     0.3(\\frac{3}{15} + \\frac{0}{15})^{0.5}   }     \\\\ \\\\    G &\\approx \\displaystyle \\frac   {0.03 + 0.23 + 0.21 + 0.26 + 0.49 + 0.08 + 0.27 + 0.13}   {0.21 + 0.23 + 0.21 + 0.26 + 0.77 + 0.58 + 0.60 + 0.13}   \\\\ \\\\    G &= \\displaystyle \\frac{1.701419}{2.986235}  \\\\ \\\\ G &= 0.569754  \\end{align*}","code":""},{"path":"https://cmmr.github.io/ecodive/articles/unifrac.html","id":"variance-adjusted","dir":"Articles","previous_headings":"","what":"Variance Adjusted","title":"UniFrac Calculations","text":"Chang et al, 2011: Variance Adjusted Weighted (VAW) UniFrac R Package ecodive: variance_adjusted_unifrac() R Package abdiv: variance_adjusted_unifrac() qiime2 qiime diversity beta-phylogenetic --p-metric weighted_normalized_unifrac --p-variance-adjusted \\begin{align*}  V &= \\displaystyle \\frac   {\\sum_{= 1}^{n} L_i\\displaystyle \\frac     {|\\frac{A_i}{A_T} - \\frac{B_i}{B_T}|}     {\\sqrt{(A_i + B_i)(A_T + B_T - A_i - B_i)}} }   {\\sum_{= 1}^{n} L_i\\displaystyle \\frac     {\\frac{A_i}{A_T} + \\frac{B_i}{B_T}}     {\\sqrt{(A_i + B_i)(A_T + B_T - A_i - B_i)}} }  \\\\ \\\\  V &= \\displaystyle \\frac   {     L_1\\displaystyle \\frac     {|\\frac{A_1}{A_T} - \\frac{B_1}{B_T}|}     {\\sqrt{(A_1 + B_1)(A_T + B_T - A_1 - B_1)}} +     \\cdots +     L_n\\displaystyle \\frac     {|\\frac{A_n}{A_T} - \\frac{B_n}{B_T}|}     {\\sqrt{(A_n + B_n)(A_T + B_T - A_n - B_n)}}   }{     L_1\\displaystyle \\frac     {\\frac{A_1}{A_T} + \\frac{B_1}{B_T}}     {\\sqrt{(A_1 + B_1)(A_T + B_T - A_1 - B_1)}} +     \\cdots +     L_n\\displaystyle \\frac     {\\frac{A_n}{A_T} + \\frac{B_n}{B_T}}     {\\sqrt{(A_n + B_n)(A_T + B_T - A_n - B_n)}}   }     \\\\ \\\\  V &= \\displaystyle \\frac   {     0.2\\displaystyle \\frac     {|\\frac{9}{15} - \\frac{7}{15}|}     {\\sqrt{(9 + 7)(15 + 15 - 9 - 7)}} +     \\cdots +     0.3\\displaystyle \\frac     {|\\frac{3}{15} - \\frac{0}{15}|}     {\\sqrt{(3 + 0)(15 + 15 - 3 - 0)}}   }{     0.2\\displaystyle \\frac     {\\frac{9}{15} + \\frac{7}{15}}     {\\sqrt{(9 + 7)(15 + 15 - 9 - 7)}} +     \\cdots +     0.3\\displaystyle \\frac     {\\frac{3}{15} + \\frac{0}{15}}     {\\sqrt{(3 + 0)(15 + 15 - 3 - 0)}}   }     \\\\ \\\\    V &\\approx \\displaystyle \\frac   {0.002 + 0.012 + 0.010 + 0.013 + 0.029 + 0.005 + 0.016 + 0.007}   {0.014 + 0.012 + 0.010 + 0.013 + 0.046 + 0.037 + 0.036 + 0.007}   \\\\ \\\\    V &= \\displaystyle \\frac{4.09389}{4.174402}  \\\\ \\\\ V &= 0.9807128  \\end{align*}","code":""},{"path":"https://cmmr.github.io/ecodive/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Daniel P. Smith. Author, maintainer. Alkek Center Metagenomics Microbiome Research. Copyright holder, funder.","code":""},{"path":"https://cmmr.github.io/ecodive/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Smith D (2025). ecodive: Parallel Memory-Efficient Ecological Diversity Metrics. R package version 1.0.0.9005, https://cmmr.github.io/ecodive/.","code":"@Manual{,   title = {ecodive: Parallel and Memory-Efficient Ecological Diversity Metrics},   author = {Daniel P. Smith},   year = {2025},   note = {R package version 1.0.0.9005},   url = {https://cmmr.github.io/ecodive/}, }"},{"path":"https://cmmr.github.io/ecodive/index.html","id":"ecodive-","dir":"","previous_headings":"","what":"Parallel and Memory-Efficient Ecological Diversity Metrics","title":"Parallel and Memory-Efficient Ecological Diversity Metrics","text":"ecodive R package calculating ecological diversity metrics parallelized memory-efficient manner. designed handle large datasets, common microbiome research.","code":""},{"path":"https://cmmr.github.io/ecodive/index.html","id":"why-ecodive","dir":"","previous_headings":"","what":"Why ecodive?","title":"Parallel and Memory-Efficient Ecological Diversity Metrics","text":"Analyzing ecological diversity often computational bottleneck, especially large datasets. ecodive addresses providing: High Performance: ecodive written C parallelized using pthreads, making dramatically faster R packages. Benchmarks show can 43,000x faster use 33,000x less memory. Zero Dependencies: package external R dependencies, making lightweight, stable, easy install. also makes ideal secure backend R packages. Comprehensive Metrics: implements wide range common alpha beta diversity metrics, including classic phylogenetic-aware methods like Faith’s PD complete UniFrac family. Ease Use: API simple integrates seamlessly popular bioinformatics packages like phyloseq rbiom.","code":""},{"path":"https://cmmr.github.io/ecodive/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Parallel and Memory-Efficient Ecological Diversity Metrics","text":"latest stable version can installed CRAN. development version available GitHub. Please note method requires compiler - see http://www.rstudio.com/ide/docs/packages/prerequisites installation succeed first try.","code":"install.packages('ecodive') install.packages('pak') pak::pak('cmmr/ecodive')"},{"path":"https://cmmr.github.io/ecodive/index.html","id":"usage","dir":"","previous_headings":"","what":"Usage","title":"Parallel and Memory-Efficient Ecological Diversity Metrics","text":"ecodive functions straightforward use. examples.","code":""},{"path":"https://cmmr.github.io/ecodive/index.html","id":"with-phyloseq-or-rbiom-objects","dir":"","previous_headings":"Usage","what":"With phyloseq or rbiom objects","title":"Parallel and Memory-Efficient Ecological Diversity Metrics","text":"easiest way use ecodive phyloseq rbiom object. objects conveniently bundle count data phylogenetic tree.","code":"library(ecodive) data(esophagus, package = 'phyloseq') data(hmp50,     package = 'rbiom')  # Calculate weighted UniFrac distance w_unifrac <- weighted_unifrac(esophagus) print(w_unifrac) #>           B         C #> C 0.1050480           #> D 0.1401124 0.1422409  # Calculate Faith's Phylogenetic Diversity faith_pd <- faith(hmp50) print(faith_pd[1:4]) #>   HMP01   HMP02   HMP03   HMP04  #> 6.22296 8.59432 8.93375 9.86597"},{"path":"https://cmmr.github.io/ecodive/index.html","id":"with-basic-r-objects","dir":"","previous_headings":"Usage","what":"With basic R objects","title":"Parallel and Memory-Efficient Ecological Diversity Metrics","text":"can also provide count data phylogenetic tree separate objects. ex_counts ex_tree objects included ecodive.","code":"## Example Data ----------------------  counts <- rarefy(ex_counts) counts #>                   Saliva Gums Nose Stool #> Streptococcus        162  309    6     1 #> Bacteroides            2    2    0   341 #> Corynebacterium        0    0  171     1 #> Haemophilus          180   34    0     1 #> Propionibacterium      1    0   82     0 #> Staphylococcus         0    0   86     1   ## Alpha Diversity -------------------  shannon(counts) #>     Saliva       Gums       Nose      Stool  #> 0.74119910 0.35692121 1.10615349 0.07927797   faith(counts, tree = ex_tree) #> Saliva   Gums   Nose  Stool  #>    180    155    101    202    ## Beta Diversity --------------------  bray_curtis(counts) #>          Saliva      Gums      Nose #> Gums  0.4260870                     #> Nose  0.9797101 0.9826087           #> Stool 0.9884058 0.9884058 0.9913043  weighted_unifrac(counts, tree = ex_tree) #>          Saliva      Gums      Nose #> Gums   36.97681                     #> Nose   67.23768  55.97101           #> Stool 109.77971 109.44058 110.00870"},{"path":"https://cmmr.github.io/ecodive/index.html","id":"documentation","dir":"","previous_headings":"","what":"Documentation","title":"Parallel and Memory-Efficient Ecological Diversity Metrics","text":"online manual ecodive available https://cmmr.github.io/ecodive/. includes getting started guide, articles alpha/beta diversity, reference pages function.","code":""},{"path":"https://cmmr.github.io/ecodive/index.html","id":"automated-tests","dir":"","previous_headings":"","what":"Automated tests","title":"Parallel and Memory-Efficient Ecological Diversity Metrics","text":"following commands check ecodive passes bundled testing suite.","code":"install.packages('testthat') testthat::test_check('ecodive')"},{"path":[]},{"path":"https://cmmr.github.io/ecodive/index.html","id":"support","dir":"","previous_headings":"Community guidelines","what":"Support","title":"Parallel and Memory-Efficient Ecological Diversity Metrics","text":"Bug reports, feature requests, general questions can submitted https://github.com/cmmr/ecodive/issues.","code":""},{"path":"https://cmmr.github.io/ecodive/index.html","id":"contributing","dir":"","previous_headings":"Community guidelines","what":"Contributing","title":"Parallel and Memory-Efficient Ecological Diversity Metrics","text":"Pull requests welcome. Please ensure contributed code covered tests documentation (add additional tests documentation needed) passes automated tests. New functions must leverage C pthreads minimize memory CPU time. Please note ecodive project released Contributor Code Conduct. contributing project, agree abide terms.","code":""},{"path":"https://cmmr.github.io/ecodive/reference/adiv_functions.html","id":null,"dir":"Reference","previous_headings":"","what":"Alpha Diversity Metrics — adiv_functions","title":"Alpha Diversity Metrics — adiv_functions","text":"Alpha Diversity Metrics","code":""},{"path":"https://cmmr.github.io/ecodive/reference/adiv_functions.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Alpha Diversity Metrics — adiv_functions","text":"","code":"ace(counts, cutoff = 10, cpus = n_cpus())  berger(counts, rescale = TRUE, cpus = n_cpus())  brillouin(counts, cpus = n_cpus())  chao1(counts, cpus = n_cpus())  faith(counts, tree = NULL, cpus = n_cpus())  fisher(counts, digits = 3L, cpus = n_cpus())  inv_simpson(counts, rescale = TRUE, cpus = n_cpus())  margalef(counts, cpus = n_cpus())  mcintosh(counts, cpus = n_cpus())  menhinick(counts, cpus = n_cpus())  observed(counts, cpus = n_cpus())  shannon(counts, rescale = TRUE, cpus = n_cpus())  simpson(counts, rescale = TRUE, cpus = n_cpus())  squares(counts, cpus = n_cpus())"},{"path":"https://cmmr.github.io/ecodive/reference/adiv_functions.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Alpha Diversity Metrics — adiv_functions","text":"counts numeric matrix count data column sample, row feature. object coercible .matrix() can given , well phyloseq, rbiom, SummarizedExperiment, TreeSummarizedExperiment objects. cutoff maximum number observations consider \"rare\". Default: 10. cpus many parallel processing threads used. default, n_cpus(), use logical CPU cores. rescale Normalize sample's counts sum 1. Default: TRUE tree phylo-class object representing phylogenetic tree OTUs counts. OTU identifiers given colnames(counts) must present tree. Can omitted tree embedded counts object attr(counts, 'tree'). digits Precision returned values, number decimal places. E.g. default digits=3 return 6.392.","code":""},{"path":"https://cmmr.github.io/ecodive/reference/adiv_functions.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Alpha Diversity Metrics — adiv_functions","text":"numeric vector.","code":""},{"path":"https://cmmr.github.io/ecodive/reference/adiv_functions.html","id":"formulas","dir":"Reference","previous_headings":"","what":"Formulas","title":"Alpha Diversity Metrics — adiv_functions","text":"Prerequisite: counts whole numbers. Given: \\(n\\) : number features (e.g. species, OTUs, ASVs, etc). \\(X_i\\) : Integer count \\(\\)-th feature. \\(X_T\\) : Total counts (.e. sequencing depth). \\(X_T = \\sum_{=1}^{n} X_i\\) \\(P_i\\) : Proportional abundance \\(\\)-th feature. \\(P_i = X_i / X_T\\) \\(F_1\\) : Number features \\(X_i = 1\\) (.e. singletons). \\(F_2\\) : Number features \\(X_i = 2\\) (.e. doubletons).","code":""},{"path":"https://cmmr.github.io/ecodive/reference/adiv_functions.html","id":"abundance-based-coverage-estimator-ace-","dir":"Reference","previous_headings":"","what":"Abundance-based Coverage Estimator (ACE)","title":"Alpha Diversity Metrics — adiv_functions","text":"Given: \\(n\\) : number features (e.g. species, OTUs, ASVs, etc). \\(r\\) : Rare cutoff. Features \\(\\le r\\) counts considered rare. \\(X_i\\) : Integer count \\(\\)-th feature. \\(F_i\\) : Number features exactly \\(\\) counts. \\(F_1\\) : Number features \\(X_i = 1\\) (.e. singletons). \\(F_{rare}\\) : Number rare features \\(X_i \\le r\\). \\(F_{abund}\\) : Number abundant features \\(X_i > r\\). \\(X_{rare}\\) : Total counts belonging rare features. \\(C_{ace}\\) : sample abundance coverage estimator, defined . \\(\\gamma_{ace}^2\\) : estimated coefficient variation, defined . \\(D_{ace}\\) : Estimated number features sample. \\(\\displaystyle C_{ace} = 1 - \\frac{F_1}{X_{rare}}\\) \\(\\displaystyle \\gamma_{ace}^2 = \\max\\left[\\frac{F_{rare} \\sum_{=1}^{r}(-1)F_i}{C_{ace}X_{rare}(X_{rare} - 1)} - 1, 0\\right]\\) \\(\\displaystyle D_{ace} = F_{abund} + \\frac{F_{rare}}{C_{ace}} + \\frac{F_1}{C_{ace}}\\gamma_{ace}^2 \\)","code":""},{"path":"https://cmmr.github.io/ecodive/reference/adiv_functions.html","id":"faith-s-phylogenetic-diversity-faith-s-pd-","dir":"Reference","previous_headings":"","what":"Faith's Phylogenetic Diversity (Faith's PD)","title":"Alpha Diversity Metrics — adiv_functions","text":"Given \\(n\\) branches lengths \\(L\\) sample's abundances \\(\\) branches coded 1 present 0 absent: \\(\\sum_{= 1}^{n} L_i A_i\\)","code":""},{"path":"https://cmmr.github.io/ecodive/reference/adiv_functions.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Alpha Diversity Metrics — adiv_functions","text":"","code":"# Example counts matrix     ex_counts #>                   Saliva Gums Nose Stool #> Streptococcus        162  793   22     1 #> Bacteroides            2    4    2   611 #> Corynebacterium        0    0  498     1 #> Haemophilus          180   87    2     1 #> Propionibacterium      1    1  251     0 #> Staphylococcus         0    1  236     1          ace(ex_counts) #> Saliva   Gums   Nose  Stool  #>    5.0    8.9    6.0    NaN           chao1(ex_counts) #> Saliva   Gums   Nose  Stool  #>    4.5    Inf    6.0    Inf           squares(ex_counts) #>    Saliva      Gums      Nose     Stool  #>  4.492762  8.243044  6.000000 20.793551"},{"path":"https://cmmr.github.io/ecodive/reference/alpha_div.html","id":null,"dir":"Reference","previous_headings":"","what":"Alpha Diversity Wrapper Function — alpha_div","title":"Alpha Diversity Wrapper Function — alpha_div","text":"Alpha Diversity Wrapper Function","code":""},{"path":"https://cmmr.github.io/ecodive/reference/alpha_div.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Alpha Diversity Wrapper Function — alpha_div","text":"","code":"alpha_div(counts, metric, ...)"},{"path":"https://cmmr.github.io/ecodive/reference/alpha_div.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Alpha Diversity Wrapper Function — alpha_div","text":"counts numeric matrix count data column sample, row feature. object coercible .matrix() can given , well phyloseq, rbiom, SummarizedExperiment, TreeSummarizedExperiment objects. metric name alpha diversity metric. One c('ace', 'berger', 'brillouin', 'chao1', 'faith', 'fisher', 'inv_simpson', 'margalef', 'mcintosh', 'menhinick', 'observed', 'shannon', 'simpson', 'squares'). Case-insensitive partial name matching supported. Programmatic access via list_metrics('alpha'). ... Additional options pass called function. .e. cpus tree.","code":""},{"path":"https://cmmr.github.io/ecodive/reference/alpha_div.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Alpha Diversity Wrapper Function — alpha_div","text":"numeric vector.","code":""},{"path":[]},{"path":"https://cmmr.github.io/ecodive/reference/alpha_div.html","id":"integer-count-requirements","dir":"Reference","previous_headings":"","what":"Integer Count Requirements","title":"Alpha Diversity Wrapper Function — alpha_div","text":"frequent critical error alpha diversity analysis providing wrong type data metric's formula. indices mathematically defined based counts individuals require raw, integer abundance data. Others based proportional abundances can accept either integer counts (converted proportions) pre-normalized proportional data. Using proportional data metric requires integer counts return error message.","code":""},{"path":[]},{"path":"https://cmmr.github.io/ecodive/reference/alpha_div.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Alpha Diversity Wrapper Function — alpha_div","text":"","code":"# Example counts matrix     ex_counts #>                   Saliva Gums Nose Stool #> Streptococcus        162  793   22     1 #> Bacteroides            2    4    2   611 #> Corynebacterium        0    0  498     1 #> Haemophilus          180   87    2     1 #> Propionibacterium      1    1  251     0 #> Staphylococcus         0    1  236     1          # Shannon diversity values     alpha_div(ex_counts, 'Shannon') #>     Saliva       Gums       Nose      Stool  #> 0.74119910 0.36684449 1.14222899 0.04824952           # Chao1 diversity values     alpha_div(ex_counts, 'c') #> Saliva   Gums   Nose  Stool  #>    4.5    Inf    6.0    Inf           # Faith PD values     alpha_div(ex_counts, 'faith', tree = ex_tree) #> Saliva   Gums   Nose  Stool  #>    180    191    215    202"},{"path":"https://cmmr.github.io/ecodive/reference/bdiv_functions.html","id":null,"dir":"Reference","previous_headings":"","what":"Beta Diversity Metrics — bdiv_functions","title":"Beta Diversity Metrics — bdiv_functions","text":"Beta Diversity Metrics","code":""},{"path":"https://cmmr.github.io/ecodive/reference/bdiv_functions.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Beta Diversity Metrics — bdiv_functions","text":"","code":"aitchison(counts, pseudocount = NULL, pairs = NULL, cpus = n_cpus())  bhattacharyya(counts, rescale = TRUE, pairs = NULL, cpus = n_cpus())  bray(counts, rescale = TRUE, pairs = NULL, cpus = n_cpus())  canberra(counts, rescale = TRUE, pairs = NULL, cpus = n_cpus())  chebyshev(counts, rescale = TRUE, pairs = NULL, cpus = n_cpus())  chord(counts, pairs = NULL, cpus = n_cpus())  clark(counts, rescale = TRUE, pairs = NULL, cpus = n_cpus())  divergence(counts, rescale = TRUE, pairs = NULL, cpus = n_cpus())  euclidean(counts, rescale = TRUE, pairs = NULL, cpus = n_cpus())  gower(counts, rescale = TRUE, pairs = NULL, cpus = n_cpus())  hellinger(counts, rescale = TRUE, pairs = NULL, cpus = n_cpus())  horn(counts, rescale = TRUE, pairs = NULL, cpus = n_cpus())  jensen(counts, rescale = TRUE, pairs = NULL, cpus = n_cpus())  jsd(counts, rescale = TRUE, pairs = NULL, cpus = n_cpus())  lorentzian(counts, rescale = TRUE, pairs = NULL, cpus = n_cpus())  manhattan(counts, rescale = TRUE, pairs = NULL, cpus = n_cpus())  matusita(counts, rescale = TRUE, pairs = NULL, cpus = n_cpus())  minkowski(counts, rescale = TRUE, power = 1.5, pairs = NULL, cpus = n_cpus())  morisita(counts, pairs = NULL, cpus = n_cpus())  motyka(counts, rescale = TRUE, pairs = NULL, cpus = n_cpus())  psym_chisq(counts, rescale = TRUE, pairs = NULL, cpus = n_cpus())  soergel(counts, rescale = TRUE, pairs = NULL, cpus = n_cpus())  squared_chisq(counts, rescale = TRUE, pairs = NULL, cpus = n_cpus())  squared_chord(counts, rescale = TRUE, pairs = NULL, cpus = n_cpus())  squared_euclidean(counts, rescale = TRUE, pairs = NULL, cpus = n_cpus())  topsoe(counts, rescale = TRUE, pairs = NULL, cpus = n_cpus())  wave_hedges(counts, rescale = TRUE, pairs = NULL, cpus = n_cpus())  hamming(counts, pairs = NULL, cpus = n_cpus())  jaccard(counts, pairs = NULL, cpus = n_cpus())  ochiai(counts, pairs = NULL, cpus = n_cpus())  sorensen(counts, pairs = NULL, cpus = n_cpus())  unweighted_unifrac(counts, tree = NULL, pairs = NULL, cpus = n_cpus())  weighted_unifrac(counts, tree = NULL, pairs = NULL, cpus = n_cpus())  normalized_unifrac(counts, tree = NULL, pairs = NULL, cpus = n_cpus())  generalized_unifrac(   counts,   tree = NULL,   alpha = 0.5,   pairs = NULL,   cpus = n_cpus() )  variance_adjusted_unifrac(counts, tree = NULL, pairs = NULL, cpus = n_cpus())"},{"path":"https://cmmr.github.io/ecodive/reference/bdiv_functions.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Beta Diversity Metrics — bdiv_functions","text":"counts numeric matrix count data column sample, row feature. object coercible .matrix() can given , well phyloseq, rbiom, SummarizedExperiment, TreeSummarizedExperiment objects. pseudocount value add counts prevent taking log(0) unobserved features. default, NULL, selects smallest non-zero value counts. pairs combinations samples distances calculated ? default value (NULL) calculates -vs-. Provide numeric logical vector specifying positions distance matrix calculate. See examples. cpus many parallel processing threads used. default, n_cpus(), use logical CPU cores. rescale Normalize sample's counts sum 1. Default: TRUE power Scaling factor magnitude differences communities (\\(p\\)). Default: 1.5 tree phylo-class object representing phylogenetic tree OTUs counts. OTU identifiers given colnames(counts) must present tree. Can omitted tree embedded counts object attr(counts, 'tree'). alpha much weight give relative abundances; value 0 1, inclusive. Setting alpha=1 equivalent normalized_unifrac().","code":""},{"path":"https://cmmr.github.io/ecodive/reference/bdiv_functions.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Beta Diversity Metrics — bdiv_functions","text":"dist object.","code":""},{"path":"https://cmmr.github.io/ecodive/reference/bdiv_functions.html","id":"formulas","dir":"Reference","previous_headings":"","what":"Formulas","title":"Beta Diversity Metrics — bdiv_functions","text":"Given: \\(n\\) : number features. \\(X_i\\), \\(Y_i\\) : Absolute counts \\(\\)-th feature samples \\(X\\) \\(Y\\). \\(X_T\\), \\(Y_T\\) : Total counts sample. \\(X_T = \\sum_{=1}^{n} X_i\\) \\(P_i\\), \\(Q_i\\) : Proportional abundances \\(X_i\\) \\(Y_i\\). \\(P_i = X_i / X_T\\) \\(X_L\\), \\(Y_L\\) : Mean log abundances. \\(X_L = \\frac{1}{n}\\sum_{=1}^{n} \\ln{X_i}\\) \\(R_i\\) : range \\(\\)-th feature across samples (max - min).","code":""},{"path":"https://cmmr.github.io/ecodive/reference/bdiv_functions.html","id":"presence-absence","dir":"Reference","previous_headings":"","what":"Presence / Absence","title":"Beta Diversity Metrics — bdiv_functions","text":"Given: \\(\\), \\(B\\) : Number features sample. \\(J\\) : Number features common.","code":""},{"path":"https://cmmr.github.io/ecodive/reference/bdiv_functions.html","id":"phylogenetic","dir":"Reference","previous_headings":"","what":"Phylogenetic","title":"Beta Diversity Metrics — bdiv_functions","text":"Given \\(n\\) branches lengths \\(L\\) pair samples' binary (\\(\\) \\(B\\)) proportional abundances (\\(P\\) \\(Q\\)) branches. See vignette('unifrac') detailed example UniFrac calculations.","code":""},{"path":"https://cmmr.github.io/ecodive/reference/bdiv_functions.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Beta Diversity Metrics — bdiv_functions","text":"Levy, ., Shalom, B. R., & Chalamish, M. (2024). guide similarity measures. arXiv. doi:10.48550/arXiv.2408.07706v1 Cha, S.-H. (2007). Comprehensive survey distance/similarity measures probability density functions. International Journal Mathematical Models Methods Applied Sciences, 1(4), 300–307.","code":""},{"path":"https://cmmr.github.io/ecodive/reference/bdiv_functions.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Beta Diversity Metrics — bdiv_functions","text":"","code":"# Example counts matrix     ex_counts #>                   Saliva Gums Nose Stool #> Streptococcus        162  793   22     1 #> Bacteroides            2    4    2   611 #> Corynebacterium        0    0  498     1 #> Haemophilus          180   87    2     1 #> Propionibacterium      1    1  251     0 #> Staphylococcus         0    1  236     1          bray(ex_counts) #>          Saliva      Gums      Nose #> Gums  0.4265973                     #> Nose  0.9713843 0.9720256           #> Stool 0.9909509 0.9911046 0.9915177          jaccard(ex_counts) #>          Saliva      Gums      Nose #> Gums  0.2000000                     #> Nose  0.3333333 0.1666667           #> Stool 0.5000000 0.3333333 0.1666667          generalized_unifrac(ex_counts, tree = ex_tree) #>          Saliva      Gums      Nose #> Gums  0.4471644                     #> Nose  0.8215129 0.7607876           #> Stool 0.9727827 0.9784242 0.9730332          # Only calculate distances for Saliva vs all.     bray(ex_counts, pairs = 1:3) #>          Saliva      Gums      Nose #> Gums  0.4265973                     #> Nose  0.9713843        NA           #> Stool 0.9909509        NA        NA"},{"path":"https://cmmr.github.io/ecodive/reference/beta_div.html","id":null,"dir":"Reference","previous_headings":"","what":"Beta Diversity Wrapper Function — beta_div","title":"Beta Diversity Wrapper Function — beta_div","text":"Beta Diversity Wrapper Function","code":""},{"path":"https://cmmr.github.io/ecodive/reference/beta_div.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Beta Diversity Wrapper Function — beta_div","text":"","code":"beta_div(counts, metric, ...)"},{"path":"https://cmmr.github.io/ecodive/reference/beta_div.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Beta Diversity Wrapper Function — beta_div","text":"counts numeric matrix count data column sample, row feature. object coercible .matrix() can given , well phyloseq, rbiom, SummarizedExperiment, TreeSummarizedExperiment objects. metric name beta diversity metric. One c('aitchison', 'bhattacharyya', 'bray', 'canberra', 'chebyshev', 'chord', 'clark', 'divergence', 'euclidean', 'generalized_unifrac', 'gower', 'hamming', 'hellinger', 'horn', 'jaccard', 'jensen', 'jsd', 'lorentzian', 'manhattan', 'matusita', 'minkowski', 'morisita', 'motyka', 'normalized_unifrac', 'ochiai', 'psym_chisq', 'soergel', 'sorensen', 'squared_chisq', 'squared_chord', 'squared_euclidean', 'topsoe', 'unweighted_unifrac', 'variance_adjusted_unifrac', 'wave_hedges', 'weighted_unifrac'). Flexible matching supported (see ). Programmatic access via list_metrics('beta'). ... Additional options pass called function. .e. tree, pairs, alpha, cpus.","code":""},{"path":"https://cmmr.github.io/ecodive/reference/beta_div.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Beta Diversity Wrapper Function — beta_div","text":"numeric vector.","code":""},{"path":"https://cmmr.github.io/ecodive/reference/beta_div.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Beta Diversity Wrapper Function — beta_div","text":"List Beta Diversity Metrics Flexible name matching Case insensitive partial matching. runs non-alpha characters converted underscores. E.g. metric = 'Weighted UniFrac selects weighted_unifrac. UniFrac names can shortened first letter plus \"unifrac\". E.g. uunifrac, w_unifrac, V UniFrac. also support partial matching. Finished code always use full primary option name avoid ambiguity future additions metrics list.","code":""},{"path":[]},{"path":"https://cmmr.github.io/ecodive/reference/beta_div.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Beta Diversity Wrapper Function — beta_div","text":"","code":"# Example counts matrix     ex_counts #>                   Saliva Gums Nose Stool #> Streptococcus        162  793   22     1 #> Bacteroides            2    4    2   611 #> Corynebacterium        0    0  498     1 #> Haemophilus          180   87    2     1 #> Propionibacterium      1    1  251     0 #> Staphylococcus         0    1  236     1          # Bray-Curtis distances     beta_div(ex_counts, 'bray') #>          Saliva      Gums      Nose #> Gums  0.4265973                     #> Nose  0.9713843 0.9720256           #> Stool 0.9909509 0.9911046 0.9915177          # Generalized UniFrac distances     beta_div(ex_counts, 'GUniFrac', tree = ex_tree) #>          Saliva      Gums      Nose #> Gums  0.4471644                     #> Nose  0.8215129 0.7607876           #> Stool 0.9727827 0.9784242 0.9730332"},{"path":"https://cmmr.github.io/ecodive/reference/documentation.html","id":null,"dir":"Reference","previous_headings":"","what":"documentation — documentation","title":"documentation — documentation","text":"documentation","code":""},{"path":"https://cmmr.github.io/ecodive/reference/documentation.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"documentation — documentation","text":"alpha much weight give relative abundances; value 0 1, inclusive. Setting alpha=1 equivalent normalized_unifrac(). counts numeric matrix count data column sample, row feature. object coercible .matrix() can given , well phyloseq, rbiom, SummarizedExperiment, TreeSummarizedExperiment objects. cpus many parallel processing threads used. default, n_cpus(), use logical CPU cores. cutoff maximum number observations consider \"rare\". Default: 10. digits Precision returned values, number decimal places. E.g. default digits=3 return 6.392. pairs combinations samples distances calculated ? default value (NULL) calculates -vs-. Provide numeric logical vector specifying positions distance matrix calculate. See examples. power Scaling factor magnitude differences communities (\\(p\\)). Default: 1.5 pseudocount value add counts prevent taking log(0) unobserved features. default, NULL, selects smallest non-zero value counts. rescale Normalize sample's counts sum 1. Default: TRUE tree phylo-class object representing phylogenetic tree OTUs counts. OTU identifiers given colnames(counts) must present tree. Can omitted tree embedded counts object attr(counts, 'tree').","code":""},{"path":"https://cmmr.github.io/ecodive/reference/ex_counts.html","id":null,"dir":"Reference","previous_headings":"","what":"Example counts matrix — ex_counts","title":"Example counts matrix — ex_counts","text":"Genera found four human body sites.","code":""},{"path":"https://cmmr.github.io/ecodive/reference/ex_counts.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Example counts matrix — ex_counts","text":"","code":"ex_counts"},{"path":"https://cmmr.github.io/ecodive/reference/ex_counts.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Example counts matrix — ex_counts","text":"matrix 4 samples (columns) x 6 genera (rows).","code":""},{"path":"https://cmmr.github.io/ecodive/reference/ex_counts.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Example counts matrix — ex_counts","text":"Derived Human Microbiome Project dataset. https://commonfund.nih.gov/hmp","code":""},{"path":"https://cmmr.github.io/ecodive/reference/ex_tree.html","id":null,"dir":"Reference","previous_headings":"","what":"Example phylogenetic tree — ex_tree","title":"Example phylogenetic tree — ex_tree","text":"Companion tree ex_counts.","code":""},{"path":"https://cmmr.github.io/ecodive/reference/ex_tree.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Example phylogenetic tree — ex_tree","text":"","code":"ex_tree"},{"path":"https://cmmr.github.io/ecodive/reference/ex_tree.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Example phylogenetic tree — ex_tree","text":"phylo object.","code":""},{"path":"https://cmmr.github.io/ecodive/reference/ex_tree.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Example phylogenetic tree — ex_tree","text":"ex_tree encodes tree structure:","code":"+----------44---------- Haemophilus   +-2-|   |   +----------------68---------------- Bacteroides   |   |             +---18---- Streptococcus   |      +--12--|   |      |      +--11-- Staphylococcus   +--11--|          |      +-----24----- Corynebacterium          +--12--|                 +--13-- Propionibacterium"},{"path":"https://cmmr.github.io/ecodive/reference/metrics.html","id":null,"dir":"Reference","previous_headings":"","what":"Find and Browse Available Metrics — list_metrics","title":"Find and Browse Available Metrics — list_metrics","text":"Programmatic access lists available metrics, associated functions.","code":""},{"path":"https://cmmr.github.io/ecodive/reference/metrics.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find and Browse Available Metrics — list_metrics","text":"","code":"list_metrics(   div = c(NA, \"alpha\", \"beta\"),   val = c(\"data.frame\", \"list\", \"func\", \"id\", \"name\", \"div\", \"phylo\", \"weighted\",     \"true_metric\"),   nm = c(NA, \"id\", \"name\"),   phylo = NULL,   weighted = NULL,   true_metric = NULL )  match_metric(   metric,   div = NULL,   phylo = NULL,   weighted = NULL,   true_metric = NULL )"},{"path":"https://cmmr.github.io/ecodive/reference/metrics.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find and Browse Available Metrics — list_metrics","text":"div, phylo, weighted, true_metric Consider metrics matching specific criteria. example, div = \"alpha\" return alpha diversity metrics. Default: div=NULL, phylo=NULL, weighted=NULL, true_metric=NULL val Sets return value function call. See \"Value\" section . Default: \"data.frame\" nm value use names returned object. Default \"id\" val \"list\" \"func\", otherwise default NA (name). metric name alpha/beta diversity metric search . Supports partial matching. non-alpha characters ignored.","code":""},{"path":"https://cmmr.github.io/ecodive/reference/metrics.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Find and Browse Available Metrics — list_metrics","text":"match_metric() list following elements. name : Metric name, e.g. \"Faith's Phylogenetic Diversity\" id : Metric ID - also name function, e.g. \"faith\" div : Either \"alpha\" \"beta\". phylo : TRUE metric requires phylogenetic tree; FALSE otherwise. weighted : TRUE metric takes relative abundance account; FALSE uses presence/absence. true_metric : TRUE metric satisfies triangle inequality; FALSE non-metric dissimilarity; NA alpha diversity metrics. func : function metric, e.g. ecodive::faith params : Formal args func, e.g. c(\"counts\", \"tree\", \"cpus\") list_metrics() returned object's type values controlled val nm arguments. val = \"data.frame\" : data.frame options sourced. val = \"list\" : list objects returned match_metric() (). val = \"func\" : list functions. val = \"id\" : character vector metric IDs. val = \"name\" : character vector metric names. val = \"div\" : character vector \"alpha\" /\"beta\". val = \"phylo\" : logical vector indicating metrics require tree. val = \"weighted\" : logical vector indicating metrics take relative abundance account (opposed just presence/absence). val = \"true_metric\" : logical vector indicating metrics satisfy triangle inequality, work better ordinations PCoA. nm set, names vector list metric ID (nm=\"id\") name (nm=\"name\"). val=\"data.frame\", names applied rownames() property data.table.","code":""},{"path":"https://cmmr.github.io/ecodive/reference/metrics.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Find and Browse Available Metrics — list_metrics","text":"","code":"# A data.frame of all available metrics.     head(list_metrics()) #>                                       name            id phylo weighted #> 1 Abundance-based Coverage Estimator (ACE)           ace FALSE     TRUE #> 2                       Aitchison Distance     aitchison FALSE     TRUE #> 3                      Berger-Parker Index        berger FALSE     TRUE #> 4                   Bhattacharyya Distance bhattacharyya FALSE     TRUE #> 5                Bray-Curtis Dissimilarity          bray FALSE     TRUE #> 6                          Brillouin Index     brillouin FALSE     TRUE #>   true_metric   div alt_ids #> 1          NA alpha    <NA> #> 2        TRUE  beta    <NA> #> 3          NA alpha    <NA> #> 4        TRUE  beta    <NA> #> 5       FALSE  beta    <NA> #> 6          NA alpha    <NA>          # All alpha diversity function names.     list_metrics('alpha', val = 'id') #>  [1] \"ace\"         \"berger\"      \"brillouin\"   \"chao1\"       \"faith\"       #>  [6] \"fisher\"      \"simpson\"     \"inv_simpson\" \"margalef\"    \"mcintosh\"    #> [11] \"menhinick\"   \"observed\"    \"shannon\"     \"squares\"              # Try to find a metric named 'otus'.     m <- match_metric('otus')          # The result is a list that includes the function.     str(m) #> List of 8 #>  $ name       : chr \"Observed Features\" #>  $ id         : chr \"observed\" #>  $ phylo      : logi FALSE #>  $ weighted   : logi FALSE #>  $ true_metric: logi NA #>  $ div        : chr \"alpha\" #>  $ func       :function (counts, cpus = n_cpus())   #>  $ params     : chr [1:2] \"counts\" \"cpus\""},{"path":"https://cmmr.github.io/ecodive/reference/n_cpus.html","id":null,"dir":"Reference","previous_headings":"","what":"Number of CPU Cores — n_cpus","title":"Number of CPU Cores — n_cpus","text":"thin wrapper around parallely::availableCores(). parallely package installed, falls back parallel::detectCores(.tests = TRUE, logical = TRUE). Returns 1 pthread support unavailable number cpus determined.","code":""},{"path":"https://cmmr.github.io/ecodive/reference/n_cpus.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Number of CPU Cores — n_cpus","text":"","code":"n_cpus()"},{"path":"https://cmmr.github.io/ecodive/reference/n_cpus.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Number of CPU Cores — n_cpus","text":"scalar integer, guaranteed least 1.","code":""},{"path":"https://cmmr.github.io/ecodive/reference/n_cpus.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Number of CPU Cores — n_cpus","text":"","code":"n_cpus() #> [1] 4"},{"path":"https://cmmr.github.io/ecodive/reference/rarefy.html","id":null,"dir":"Reference","previous_headings":"","what":"Rarefy OTU counts. — rarefy","title":"Rarefy OTU counts. — rarefy","text":"Sub-sample OTU observations samples equal number. called data non-integer abundances, values re-scaled integers 1 depth sum depth.","code":""},{"path":"https://cmmr.github.io/ecodive/reference/rarefy.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Rarefy OTU counts. — rarefy","text":"","code":"rarefy(   counts,   depth = 0.1,   n_samples = NULL,   seed = 0,   times = NULL,   cpus = n_cpus() )"},{"path":"https://cmmr.github.io/ecodive/reference/rarefy.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Rarefy OTU counts. — rarefy","text":"counts numeric matrix count data column sample, row feature. object coercible .matrix() can given , well phyloseq, rbiom, SummarizedExperiment, TreeSummarizedExperiment objects. depth many observations keep per sample. 0 < depth < 1, taken minimum percentage dataset's observations keep. Ignored n_samples specified. Default: 0.1 n_samples number samples keep. 0 < n_samples < 1, taken percentage samples keep. negative, number samples dropped. 0, samples kept. NULL, depth used instead. Default: NULL seed integer seed randomizing observations keep drop. need create different random rarefactions data, set seed different number time. times many independent rarefactions perform. set, rarefy() return list matrices. seeds matrix sequential, starting seed. cpus many parallel processing threads used. default, n_cpus(), use logical CPU cores.","code":""},{"path":"https://cmmr.github.io/ecodive/reference/rarefy.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Rarefy OTU counts. — rarefy","text":"integer matrix.","code":""},{"path":"https://cmmr.github.io/ecodive/reference/rarefy.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Rarefy OTU counts. — rarefy","text":"","code":"# Create an OTU matrix with 4 samples (A-D) and 5 OTUs.     counts <- matrix(       data     = c(4,0,3,2,6,0,8,0,0,5,0,9,0,0,7,0,10,0,0,1),       nrow     = 5,       dimnames = list(paste0('OTU', 1:5), LETTERS[1:4]) )     counts #>      A B C  D #> OTU1 4 0 0  0 #> OTU2 0 8 9 10 #> OTU3 3 0 0  0 #> OTU4 2 0 0  0 #> OTU5 6 5 7  1     colSums(counts) #>  A  B  C  D  #> 15 13 16 11           counts <- rarefy(counts, depth = 14)     counts #>      A B C D #> OTU1 4 0 0 0 #> OTU2 0 0 9 0 #> OTU3 3 0 0 0 #> OTU4 2 0 0 0 #> OTU5 5 0 5 0     colSums(counts) #>  A  B  C  D  #> 14  0 14  0"},{"path":"https://cmmr.github.io/ecodive/reference/read_tree.html","id":null,"dir":"Reference","previous_headings":"","what":"Read a newick formatted phylogenetic tree. — read_tree","title":"Read a newick formatted phylogenetic tree. — read_tree","text":"phylogenetic tree required computing UniFrac distance matrices. can load tree file providing tree string directly. tree must Newick format, also known parenthetic format New Hampshire format.","code":""},{"path":"https://cmmr.github.io/ecodive/reference/read_tree.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Read a newick formatted phylogenetic tree. — read_tree","text":"","code":"read_tree(newick, underscores = FALSE)"},{"path":"https://cmmr.github.io/ecodive/reference/read_tree.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Read a newick formatted phylogenetic tree. — read_tree","text":"newick Input data either file path, URL, Newick string. Compressed (gzip bzip2) files also supported. underscores TRUE, underscores unquoted names remain underscores. FALSE, underscores unquoted named converted spaces.","code":""},{"path":"https://cmmr.github.io/ecodive/reference/read_tree.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Read a newick formatted phylogenetic tree. — read_tree","text":"phylo class object representing tree.","code":""},{"path":"https://cmmr.github.io/ecodive/reference/read_tree.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Read a newick formatted phylogenetic tree. — read_tree","text":"","code":"tree <- read_tree(\"         (A:0.99,((B:0.87,C:0.89):0.51,(((D:0.16,(E:0.83,F:0.96)         :0.94):0.69,(G:0.92,(H:0.62,I:0.85):0.54):0.23):0.74,J:0.1         2):0.43):0.67);\")     class(tree) #> [1] \"phylo\""},{"path":"https://cmmr.github.io/ecodive/news/index.html","id":"ecodive-100","dir":"Changelog","previous_headings":"","what":"ecodive 1.0.0","title":"ecodive 1.0.0","text":"CRAN release: 2025-08-22 first release ecodive.","code":""}]
