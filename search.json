[{"path":[]},{"path":"https://cmmr.github.io/ecodive/CODE_OF_CONDUCT.html","id":"our-pledge","dir":"","previous_headings":"","what":"Our Pledge","title":"Contributor Covenant Code of Conduct","text":"members, contributors, leaders pledge make participation community harassment-free experience everyone, regardless age, body size, visible invisible disability, ethnicity, sex characteristics, gender identity expression, level experience, education, socio-economic status, nationality, personal appearance, race, caste, color, religion, sexual identity orientation. pledge act interact ways contribute open, welcoming, diverse, inclusive, healthy community.","code":""},{"path":"https://cmmr.github.io/ecodive/CODE_OF_CONDUCT.html","id":"our-standards","dir":"","previous_headings":"","what":"Our Standards","title":"Contributor Covenant Code of Conduct","text":"Examples behavior contributes positive environment community include: Demonstrating empathy kindness toward people respectful differing opinions, viewpoints, experiences Giving gracefully accepting constructive feedback Accepting responsibility apologizing affected mistakes, learning experience Focusing best just us individuals, overall community Examples unacceptable behavior include: use sexualized language imagery, sexual attention advances kind Trolling, insulting derogatory comments, personal political attacks Public private harassment Publishing others’ private information, physical email address, without explicit permission conduct reasonably considered inappropriate professional setting","code":""},{"path":"https://cmmr.github.io/ecodive/CODE_OF_CONDUCT.html","id":"enforcement-responsibilities","dir":"","previous_headings":"","what":"Enforcement Responsibilities","title":"Contributor Covenant Code of Conduct","text":"Community leaders responsible clarifying enforcing standards acceptable behavior take appropriate fair corrective action response behavior deem inappropriate, threatening, offensive, harmful. Community leaders right responsibility remove, edit, reject comments, commits, code, wiki edits, issues, contributions aligned Code Conduct, communicate reasons moderation decisions appropriate.","code":""},{"path":"https://cmmr.github.io/ecodive/CODE_OF_CONDUCT.html","id":"scope","dir":"","previous_headings":"","what":"Scope","title":"Contributor Covenant Code of Conduct","text":"Code Conduct applies within community spaces, also applies individual officially representing community public spaces. Examples representing community include using official e-mail address, posting via official social media account, acting appointed representative online offline event.","code":""},{"path":"https://cmmr.github.io/ecodive/CODE_OF_CONDUCT.html","id":"enforcement","dir":"","previous_headings":"","what":"Enforcement","title":"Contributor Covenant Code of Conduct","text":"Instances abusive, harassing, otherwise unacceptable behavior may reported community leaders responsible enforcement dansmith01@gmail.com. complaints reviewed investigated promptly fairly. community leaders obligated respect privacy security reporter incident.","code":""},{"path":"https://cmmr.github.io/ecodive/CODE_OF_CONDUCT.html","id":"enforcement-guidelines","dir":"","previous_headings":"","what":"Enforcement Guidelines","title":"Contributor Covenant Code of Conduct","text":"Community leaders follow Community Impact Guidelines determining consequences action deem violation Code Conduct:","code":""},{"path":"https://cmmr.github.io/ecodive/CODE_OF_CONDUCT.html","id":"id_1-correction","dir":"","previous_headings":"Enforcement Guidelines","what":"1. Correction","title":"Contributor Covenant Code of Conduct","text":"Community Impact: Use inappropriate language behavior deemed unprofessional unwelcome community. Consequence: private, written warning community leaders, providing clarity around nature violation explanation behavior inappropriate. public apology may requested.","code":""},{"path":"https://cmmr.github.io/ecodive/CODE_OF_CONDUCT.html","id":"id_2-warning","dir":"","previous_headings":"Enforcement Guidelines","what":"2. Warning","title":"Contributor Covenant Code of Conduct","text":"Community Impact: violation single incident series actions. Consequence: warning consequences continued behavior. interaction people involved, including unsolicited interaction enforcing Code Conduct, specified period time. includes avoiding interactions community spaces well external channels like social media. Violating terms may lead temporary permanent ban.","code":""},{"path":"https://cmmr.github.io/ecodive/CODE_OF_CONDUCT.html","id":"id_3-temporary-ban","dir":"","previous_headings":"Enforcement Guidelines","what":"3. Temporary Ban","title":"Contributor Covenant Code of Conduct","text":"Community Impact: serious violation community standards, including sustained inappropriate behavior. Consequence: temporary ban sort interaction public communication community specified period time. public private interaction people involved, including unsolicited interaction enforcing Code Conduct, allowed period. Violating terms may lead permanent ban.","code":""},{"path":"https://cmmr.github.io/ecodive/CODE_OF_CONDUCT.html","id":"id_4-permanent-ban","dir":"","previous_headings":"Enforcement Guidelines","what":"4. Permanent Ban","title":"Contributor Covenant Code of Conduct","text":"Community Impact: Demonstrating pattern violation community standards, including sustained inappropriate behavior, harassment individual, aggression toward disparagement classes individuals. Consequence: permanent ban sort public interaction within community.","code":""},{"path":"https://cmmr.github.io/ecodive/CODE_OF_CONDUCT.html","id":"attribution","dir":"","previous_headings":"","what":"Attribution","title":"Contributor Covenant Code of Conduct","text":"Code Conduct adapted Contributor Covenant, version 2.1, available https://www.contributor-covenant.org/version/2/1/code_of_conduct.html. Community Impact Guidelines inspired [Mozilla’s code conduct enforcement ladder][https://github.com/mozilla/inclusion]. answers common questions code conduct, see FAQ https://www.contributor-covenant.org/faq. Translations available https://www.contributor-covenant.org/translations.","code":""},{"path":"https://cmmr.github.io/ecodive/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2025 ecodive authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://cmmr.github.io/ecodive/articles/adiv.html","id":"input-matrix","dir":"Articles","previous_headings":"","what":"Input Matrix","title":"Alpha Diversity","text":"’ll use ex_counts feature table included ecodive. contains number observations bacterial genera sample. text , can substitute word ‘genera’ feature interest data.","code":"library(ecodive)  counts <- rarefy(ex_counts) t(counts) #>                   Saliva Gums Nose Stool #> Streptococcus        162  309    6     1 #> Bacteroides            2    2    0   341 #> Corynebacterium        0    0  171     1 #> Haemophilus          180   34    0     1 #> Propionibacterium      1    0   82     0 #> Staphylococcus         0    0   86     1"},{"path":"https://cmmr.github.io/ecodive/articles/adiv.html","id":"alpha-diversity","dir":"Articles","previous_headings":"","what":"Alpha Diversity","title":"Alpha Diversity","text":"Alpha diversity measure diversity within single sample. Depending metric, may measure richness /evenness.","code":""},{"path":"https://cmmr.github.io/ecodive/articles/adiv.html","id":"richness","dir":"Articles","previous_headings":"Alpha Diversity","what":"Richness","title":"Alpha Diversity","text":"Richness many genera present sample. simplest metric count non-zero genera. can base R’s rowSums() ecodive’s observed(). Chao1 metric takes step including unobserved low abundance genera, inferred using number times counts == 1 vs counts == 2.","code":"rowSums(counts > 0) #> Saliva   Gums   Nose  Stool  #>      4      3      4      5   observed(counts) #> Saliva   Gums   Nose  Stool  #>      4      3      4      5 # Infers 8 unobserved genera chao1(c(1, 1, 1, 1, 2, 5, 5, 5)) #> [1] 16  # Infers less than 1 unobserved genera chao1(c(1, 2, 2, 2, 2, 5, 5, 5)) #> [1] 8.125  # Datasets without 1s and 2s give Inf or NaN chao1(counts) #> Saliva   Gums   Nose  Stool  #>    4.5    3.0    NaN    Inf"},{"path":"https://cmmr.github.io/ecodive/articles/adiv.html","id":"evenness","dir":"Articles","previous_headings":"Alpha Diversity","what":"Evenness","title":"Alpha Diversity","text":"Evenness equally distributed genera within sample. Simpson metric good measure evenness.","code":"# High Evenness simpson(c(20, 20, 20, 20, 20)) #> [1] 0.8  # Low Evenness simpson(c(100, 1, 1, 1, 1)) #> [1] 0.07507396  # Stool < Gums < Saliva < Nose sort(simpson(counts)) #>      Stool       Gums     Saliva       Nose  #> 0.02302037 0.18806133 0.50725478 0.63539593"},{"path":"https://cmmr.github.io/ecodive/articles/adiv.html","id":"richness-and-evenness","dir":"Articles","previous_headings":"Alpha Diversity","what":"Richness and Evenness","title":"Alpha Diversity","text":"Shannon diversity index weights richness evenness.","code":"# Low richness, Low evenness shannon(c(1, 1, 100)) #> [1] 0.1101001  # Low richness, High evenness shannon(c(100, 100, 100)) #> [1] 1.098612  # High richness, Low evenness shannon(1:100) #> [1] 4.416898  # High richness, High evenness shannon(rep(100, 100)) #> [1] 4.60517  # Stool < Gums < Saliva < Nose sort(shannon(counts)) #>      Stool       Gums     Saliva       Nose  #> 0.07927797 0.35692121 0.74119910 1.10615349"},{"path":"https://cmmr.github.io/ecodive/articles/adiv.html","id":"phylogenetic-alpha-diversity","dir":"Articles","previous_headings":"Alpha Diversity","what":"Phylogenetic Alpha Diversity","title":"Alpha Diversity","text":"Faith’s phylogenetic diversity index incorporates phylogenetic tree genera order measure many tree’s branches represented sample.","code":"# ex_tree: # #       +----------44---------- Haemophilus #   +-2-| #   |   +----------------68---------------- Bacteroides   #   |                       #   |             +---18---- Streptococcus #   |      +--12--|        #   |      |      +--11-- Staphylococcus #   +--11--|               #          |      +-----24----- Corynebacterium #          +--12--| #                 +--13-- Propionibacterium   faith(c(Propionibacterium = 1, Corynebacterium = 1), tree = ex_tree) #> [1] 60  faith(c(Propionibacterium = 1, Haemophilus = 1), tree = ex_tree) #> [1] 82  # Nose < Gums < Saliva < Stool sort(faith(counts, tree = ex_tree)) #>   Nose   Gums Saliva  Stool  #>    101    155    180    202"},{"path":"https://cmmr.github.io/ecodive/articles/bdiv.html","id":"input-matrix","dir":"Articles","previous_headings":"","what":"Input Matrix","title":"Beta Diversity","text":"’ll use ex_counts feature table included ecodive. contains number observations bacterial genera sample. text , can substitute word ‘genera’ feature interest data.","code":"library(ecodive)  counts <- rarefy(ex_counts) t(counts) #>                   Saliva Gums Nose Stool #> Streptococcus        162  309    6     1 #> Bacteroides            2    2    0   341 #> Corynebacterium        0    0  171     1 #> Haemophilus          180   34    0     1 #> Propionibacterium      1    0   82     0 #> Staphylococcus         0    0   86     1"},{"path":"https://cmmr.github.io/ecodive/articles/bdiv.html","id":"beta-diversity","dir":"Articles","previous_headings":"","what":"Beta Diversity","title":"Beta Diversity","text":"Beta diversity measure different two samples . Looking counts matrix , can easily see saliva gums similar, saliva stool different. different metrics described quantify difference, referred “distance” “dissimilarity” pair samples. distance 0 identical samples 1 completely different samples.","code":""},{"path":"https://cmmr.github.io/ecodive/articles/bdiv.html","id":"weighted-vs-unweighted","dir":"Articles","previous_headings":"Beta Diversity","what":"Weighted vs Unweighted","title":"Beta Diversity","text":"Weighted metrics take relative abundances account, whereas unweighted metrics consider presence/absence. determine metrics weighted unweighted, consult list_metrics(). Note sorsensen() equivalent bray(norm = 'binary'), jaccard() equivalent soergel(norm = 'binary').","code":"list_metrics('beta', 'id', weighted = FALSE) #> [1] \"sorensen\" \"hamming\"  \"jaccard\"  \"ochiai\"  list_metrics('beta', 'id', weighted = TRUE) #>  [1] \"aitchison\"                 \"bhattacharyya\"             \"bray\"                      #>  [4] \"canberra\"                  \"chebyshev\"                 \"chord\"                     #>  [7] \"clark\"                     \"divergence\"                \"euclidean\"                 #> [10] \"generalized_unifrac\"       \"gower\"                     \"hellinger\"                 #> [13] \"horn\"                      \"jensen\"                    \"jsd\"                       #> [16] \"lorentzian\"                \"manhattan\"                 \"matusita\"                  #> [19] \"minkowski\"                 \"morisita\"                  \"motyka\"                    #> [22] \"normalized_unifrac\"        \"psym_chisq\"                \"soergel\"                   #> [25] \"squared_chisq\"             \"squared_chord\"             \"squared_euclidean\"         #> [28] \"topsoe\"                    \"unweighted_unifrac\"        \"variance_adjusted_unifrac\" #> [31] \"wave_hedges\"               \"weighted_unifrac\""},{"path":"https://cmmr.github.io/ecodive/articles/bdiv.html","id":"partial-calculation","dir":"Articles","previous_headings":"","what":"Partial Calculation","title":"Beta Diversity","text":"default value pairs=NULL ecodive’s beta diversity functions results returned -vs-distance matrix completely filled . reference-vs-comparison, can use pairs parameter skip unwanted calculations save CPU time. larger dataset, noticeable improvement . pairs argument can : numeric vector, giving positions result calculate. logical vector, indicating whether calculate position result. function(,j) returns whether rows j compared. Therefore, following equivalent: ordering pairs follows pairings produced combn(). , instance, use gums reference sample:","code":"bray(counts) #>          Saliva      Gums      Nose #> Gums  0.4260870                     #> Nose  0.9797101 0.9826087           #> Stool 0.9884058 0.9884058 0.9913043 bray(counts, pairs = 1:3) #>          Saliva      Gums      Nose #> Gums  0.4260870                     #> Nose  0.9797101        NA           #> Stool 0.9884058        NA        NA bray(counts, pairs = 1:3) bray(counts, pairs = c(TRUE, TRUE, TRUE, FALSE, FALSE, FALSE)) bray(counts, pairs = function (i, j) i == 1) # Column index pairings combn(nrow(counts), 2) #>      [,1] [,2] [,3] [,4] [,5] [,6] #> [1,]    1    1    1    2    2    3 #> [2,]    2    3    4    3    4    4  # Sample name pairings combn(rownames(counts), 2) #>      [,1]     [,2]     [,3]     [,4]   [,5]    [,6]    #> [1,] \"Saliva\" \"Saliva\" \"Saliva\" \"Gums\" \"Gums\"  \"Nose\"  #> [2,] \"Gums\"   \"Nose\"   \"Stool\"  \"Nose\" \"Stool\" \"Stool\" my_combn <- combn(rownames(counts), 2) my_pairs <- my_combn[1,] == 'Gums' | my_combn[2,] == 'Gums'  my_pairs #> [1]  TRUE FALSE FALSE  TRUE  TRUE FALSE  bray(counts, pairs = my_pairs) #>          Saliva      Gums      Nose #> Gums  0.4260870                     #> Nose         NA 0.9826087           #> Stool        NA 0.9884058        NA"},{"path":"https://cmmr.github.io/ecodive/articles/bdiv_guide.html","id":"a-practical-guide-to-metric-selection-aligning-method-with-research-question","dir":"Articles","previous_headings":"","what":"A Practical Guide to Metric Selection:Aligning Method with Research Question","title":"Selecting a Beta Diversity Metric","text":"theoretical mathematical properties various beta diversity metrics provide foundation making informed choice. However, ultimate decision must driven specific research question nature dataset. vignette provides practical framework, including decision tree illustrative case studies, guide researchers scientific question appropriate metric.","code":""},{"path":"https://cmmr.github.io/ecodive/articles/bdiv_guide.html","id":"a-decision-tree-for-metric-selection","dir":"Articles","previous_headings":"A Practical Guide to Metric Selection:Aligning Method with Research Question","what":"A Decision Tree for Metric Selection","title":"Selecting a Beta Diversity Metric","text":"decision tree presents series questions help researcher systematically narrow field 37 metrics small, relevant subset.","code":""},{"path":"https://cmmr.github.io/ecodive/articles/bdiv_guide.html","id":"do-you-have-a-reliable-phylogenetic-tree-relating-your-taxa-e-g--asvsotus","dir":"Articles","previous_headings":"A Practical Guide to Metric Selection:Aligning Method with Research Question > A Decision Tree for Metric Selection","what":"1. Do you have a reliable phylogenetic tree relating your taxa (e.g., ASVs/OTUs)?","title":"Selecting a Beta Diversity Metric","text":"YES: analysis can likely leverage phylogenetic information. primarily interested presence/absence entire evolutionary lineages (e.g., detecting invasion novel phylum)? -> Start Unweighted UniFrac. primarily interested shifts abundance major, well-established lineages (e.g., Firmicutes/Bacteroidetes ratio)? -> Start Weighted UniFrac. interested robust analysis captures changes across rare, moderate, abundant lineages, unsure? -> Use Generalized UniFrac (α=0.5) powerful balanced primary choice. Consider using Variance-Adjusted Weighted UniFrac increased statistical power uneven sample sizes. : must use Non-Phylogenetic Metric. Proceed Question 2.","code":""},{"path":"https://cmmr.github.io/ecodive/articles/bdiv_guide.html","id":"is-your-data-compositional-i-e--relative-abundances-from-high-throughput-sequencing","dir":"Articles","previous_headings":"A Practical Guide to Metric Selection:Aligning Method with Research Question > A Decision Tree for Metric Selection","what":"2. Is your data compositional (i.e., relative abundances from high-throughput sequencing)?","title":"Selecting a Beta Diversity Metric","text":"YES: must account relative nature data. statistically rigorous approach use compositional metric. -> primary choice Aitchison distance. prepared handle zeros using pseudocount imputation method. choose use non-compositional metric, select one robust transformations proportions less sensitive extreme values. -> Good secondary choices include Hellinger, Jensen-Shannon Divergence, Horn-Morisita. Note fully address compositionality issue often better behaved Bray-Curtis Euclidean relative data. : data represents absolute counts measurements (e.g., microscopy quantitative PCR). Proceed Question 3.","code":""},{"path":"https://cmmr.github.io/ecodive/articles/bdiv_guide.html","id":"what-is-the-primary-ecological-signal-you-want-to-detect","dir":"Articles","previous_headings":"A Practical Guide to Metric Selection:Aligning Method with Research Question > A Decision Tree for Metric Selection","what":"3. What is the primary ecological signal you want to detect?","title":"Selecting a Beta Diversity Metric","text":"Presence/Absence specific taxa (Community Membership): interested species present, regardless abundance. -> Choose Qualitative (Binary) Metric. best options Jaccard (standard turnover) Dice-Sorensen (gives weight shared species). Shifts abundance taxa (Community Structure): interested species dominant abundances change. -> Choose Quantitative Metric. want robust, widely understood standard sensitive dominant taxa -> Use Bray-Curtis. data consists raw integer counts concerned sample size effects -> Use Morisita index. want -weight influence hyper-dominant species balanced view abundance changes -> Use Hellinger distance. concerned small changes rare taxa amplified -> Avoid Canberra distance.","code":""},{"path":"https://cmmr.github.io/ecodive/articles/bdiv_guide.html","id":"case-studies-matching-metrics-to-microbiome-research-questions","dir":"Articles","previous_headings":"A Practical Guide to Metric Selection:Aligning Method with Research Question","what":"Case Studies: Matching Metrics to Microbiome Research Questions","title":"Selecting a Beta Diversity Metric","text":"following case studies illustrate choice metric directly influences ability answer specific biological question.","code":""},{"path":"https://cmmr.github.io/ecodive/articles/bdiv_guide.html","id":"case-study-1-does-antibiotic-treatment-eliminate-specific-rare-potentially-pathogenic-taxa","dir":"Articles","previous_headings":"A Practical Guide to Metric Selection:Aligning Method with Research Question > Case Studies: Matching Metrics to Microbiome Research Questions","what":"Case Study 1: Does antibiotic treatment eliminate specific rare, potentially pathogenic taxa?","title":"Selecting a Beta Diversity Metric","text":"Research Question: question explicitly presence absence key organisms, likely rare overall community. massive shifts abundant, commensal bacteria secondary primary question pathogen eradication. Recommended Metric: Jaccard Unweighted UniFrac. Justification: quantitative metric like Bray-Curtis dominated large-scale disruption dominant taxa like Bacteroides Faecalibacterium. signal rare pathogen’s disappearance completely lost. contrast, qualitative metric like Jaccard treats disappearance pathogen (change 1 0) significant event, directly addressing research question. phylogenetic tree available, Unweighted UniFrac even better, capture loss entire evolutionary lineage, might biologically meaningful loss single ASV.","code":""},{"path":"https://cmmr.github.io/ecodive/articles/bdiv_guide.html","id":"case-study-2-how-does-a-high-fiber-vs--high-fat-diet-alter-the-overall-gut-microbiome-structure","dir":"Articles","previous_headings":"A Practical Guide to Metric Selection:Aligning Method with Research Question > Case Studies: Matching Metrics to Microbiome Research Questions","what":"Case Study 2: How does a high-fiber vs. high-fat diet alter the overall gut microbiome structure?","title":"Selecting a Beta Diversity Metric","text":"Research Question: question concerns broad, systemic shifts community’s metabolic capacity. expected signal change abundance major functional guilds—example, increase fiber-degrading Firmicutes decrease bile-acid-metabolizing bacteria. Recommended Metrics: Bray-Curtis Hellinger. Justification: question community structure abundance major players. Bray-Curtis excellent choice sensitive shifts dominant abundant taxa. Using Hellinger complementary metric robust strategy. Hellinger distance, using square-root transformation, -weight influence hyper-dominant taxa, providing slightly different potentially stable view overall structural change. metrics show significant difference diet groups, conclusion strong.","code":""},{"path":"https://cmmr.github.io/ecodive/articles/bdiv_guide.html","id":"case-study-3-comparing-gut-communities-with-vastly-different-dominant-phyla-e-g--bacteroidetes-dominant-vs--firmicutes-dominant-","dir":"Articles","previous_headings":"A Practical Guide to Metric Selection:Aligning Method with Research Question > Case Studies: Matching Metrics to Microbiome Research Questions","what":"Case Study 3: Comparing gut communities with vastly different dominant phyla (e.g., Bacteroidetes-dominant vs. Firmicutes-dominant).","title":"Selecting a Beta Diversity Metric","text":"Research Question: goal understand , subtle structural differences exist two community types, beyond obvious phylum-level dominance. relative proportions less abundant genera within Proteobacteria different, example? Recommended Metric: Aitchison distance. Justification: classic compositionality problem. Bray-Curtis analysis, massive difference abundance Firmicutes vs. Bacteroidetes create large distance two sample types variation rendered invisible. ordination plot likely show two tight, distant clusters, reveal nothing internal structure clusters. Aitchison distance, using log-ratios, effectively normalizes dominant phylum calculates distance based relative proportions taxa one another. allows researcher “see ” dominance effect investigate subtle structural differences directly address research question.","code":""},{"path":"https://cmmr.github.io/ecodive/articles/bdiv_guide.html","id":"case-study-4-are-the-microbial-communities-in-two-soil-types-different-due-to-the-loss-of-a-deep-evolutionary-lineage-or-due-to-shifts-within-the-same-major-families","dir":"Articles","previous_headings":"A Practical Guide to Metric Selection:Aligning Method with Research Question > Case Studies: Matching Metrics to Microbiome Research Questions","what":"Case Study 4: Are the microbial communities in two soil types different due to the loss of a deep evolutionary lineage or due to shifts within the same major families?","title":"Selecting a Beta Diversity Metric","text":"Research Question: question explicitly phylogenetic hierarchical. seeks distinguish two distinct types evolutionary change. Recommended Metrics: Generalized UniFrac (GUniFrac) varying alpha values, comparison Unweighted Weighted UniFrac. Justification: non-phylogenetic metric answer question. best approach use GUniFrac framework. researcher calculate distance matrix using multiple values α (e.g., 0, 0.5, 1). separation soil types significant α=0 (Unweighted UniFrac), suggests difference driven presence/absence entire clades (deep evolutionary change). separation strongest α=1 (Weighted UniFrac), suggests difference due abundance shifts within lineages present soils (shallow change). signal strongest α=0.5, points changes moderately abundant taxa key drivers, providing nuanced answer. Content generated Google Gemini. Verified formatted Daniel Smith. Sept. 5th, 2025.","code":""},{"path":[]},{"path":"https://cmmr.github.io/ecodive/articles/benchmark.html","id":"state-of-the-field","dir":"Articles","previous_headings":"Introduction","what":"State of the Field","title":"Benchmarks","text":"analysis provides comparative benchmark R packages designed calculating standard phylogenetic metrics alpha beta diversity. primary objective evaluate computational efficiency, focus processing speed memory allocation. Packages rely foundational libraries dependencies omitted study isolate performance core implementations.","code":""},{"path":"https://cmmr.github.io/ecodive/articles/benchmark.html","id":"methodology","dir":"Articles","previous_headings":"Introduction","what":"Methodology","title":"Benchmarks","text":"bench R package employed quantify computational runtime memory allocation diversity algorithms within 15 selected packages. benchmarks executed host system following hardware software configuration: Furthermore, bench::mark() function utilized verify outputs benchmarked expressions numerically equivalent, ensuring consistency comparability results.","code":"CPU: 6-Core Intel i5-9600K @ 3.70GHz RAM: 64.0 GB OS: Windows 11 Pro (64-bit, Version 24H2, Build 26100.4652)"},{"path":"https://cmmr.github.io/ecodive/articles/benchmark.html","id":"setup","dir":"Articles","previous_headings":"","what":"Setup","title":"Benchmarks","text":"Two standard datasets rbiom R package, hmp50 gems, selected evaluation. hmp50 dataset, includes 50 samples associated phylogenetic tree, used benchmark computationally intensive phylogenetic metrics, UniFrac Faith’s PD. traditional diversity metrics, significantly less demanding, larger gems dataset, comprising 1,006 samples, employed. account heterogeneous input output formats across 15 R packages, necessary data transformations performed. ensure benchmarks exclusively measured performance diversity calculations, data conversion steps executed outside timed code blocks whenever possible.","code":"install.packages('pak')  # Tools and Datasets for Benchmarking Report pak::pkg_install(pkg = c(   'bench', 'dplyr', 'ggplot2', 'ggrepel', 'rbiom', 'svglite' ))  # Diversity Metric Implementations pak::pkg_install(pkg = c(   'abdiv', 'adiv', 'ecodist', 'ecodive', 'entropart', 'GUniFrac',    'kasperskytte/ampvis2', 'labdsv', 'parallelDist', 'philentropy',    'phyloregion', 'phyloseq', 'picante', 'tabula', 'vegan' ))   # Software Versions  version$version.string #> [1] \"R version 4.5.1 (2025-06-13 ucrt)\"  data.frame(ver = sapply(FUN = packageDescription, fields = 'Version', c(   'bench', 'dplyr', 'ggplot2', 'ggrepel', 'rbiom',   'abdiv', 'adiv', 'ecodist', 'ecodive', 'entropart', 'GUniFrac',    'ampvis2', 'labdsv', 'parallelDist', 'philentropy',    'phyloregion', 'phyloseq', 'picante', 'tabula', 'vegan' ))) #>                     ver #> bench             1.1.4 #> dplyr             1.1.4 #> ggplot2           3.5.2 #> ggrepel           0.9.6 #> rbiom             2.2.1 #> abdiv             0.2.0 #> adiv              2.2.1 #> ecodist           2.1.3 #> ecodive           2.0.0 #> entropart        1.6-16 #> GUniFrac            1.8 #> ampvis2           2.8.9 #> labdsv            2.1-2 #> parallelDist      0.2.6 #> philentropy       0.9.0 #> phyloregion       1.0.9 #> phyloseq         1.52.0 #> picante           1.8.2 #> tabula            3.3.1 #> vegan             2.7-1  library(bench) library(ggplot2) library(ggrepel) library(dplyr)  (n_cpus <- ecodive::n_cpus()) #> [1] 6  # abdiv only accepts two samples at a time pairwise <- function (f, data, ...) {   pairs <- utils::combn(nrow(data), 2)   structure(     mapply(       FUN = function (i, j) f(data[i,], data[j,], ...),        i   = pairs[1,], j = pairs[2,] ),     class  = 'dist',     Labels = rownames(data),     Size   = nrow(data),     Diag   = FALSE,     Upper  = FALSE ) }   # Remove any extraneous attributes from dist objects, # allowing them to be compared with `all.equal()`. cleanup <- function (x) {   for (i in setdiff(names(attributes(x)), c('class', 'Labels', 'Size', 'Diag', 'Upper')))     attr(x, i) <- NULL   return (x) }   # HMP50 dataset has 50 samples; convert to relative abundances hmp50      <- rbiom::hmp50 hmp50_phy  <- rbiom::convert_to_phyloseq(hmp50) hmp50_mtx  <- t(apply(as.matrix(hmp50), 2L, function (x) x / sum(x))) hmp50_tree <- hmp50$tree   # GEMS dataset has 1006 samples; convert to relative abundances gems_mtx <- t(apply(as.matrix(rbiom::gems), 2L, function (x) x / sum(x)))   ## Bray-Curtis Dissimilarity bray_curtis_res <- bench::mark(   iterations = 10,   'abdiv'        = cleanup(pairwise(abdiv::bray_curtis, gems_mtx)),   'ecodist'      = cleanup(ecodist::bcdist(gems_mtx)),   'ecodive'      = cleanup(ecodive::bray(gems_mtx, norm = 'none')),   'labdsv'       = cleanup(labdsv::dsvdis(gems_mtx, 'bray/curtis')),   'parallelDist' = cleanup(parallelDist::parallelDist(gems_mtx, 'bray')),   'philentropy'  = cleanup(philentropy::distance(gems_mtx, 'sorensen', test.na = FALSE, use.row.names = TRUE, as.dist.obj = TRUE, mute.message = TRUE)),   'tabula'       = cleanup(1 - pairwise(tabula::index_bray, gems_mtx)),   'vegan'        = cleanup(vegan::vegdist(gems_mtx, 'bray')) )   ## Jaccard Distance jaccard_res <- bench::mark(   iterations = 10,   'abdiv'        = cleanup(pairwise(abdiv::jaccard, gems_mtx)),   'ecodist'      = cleanup(ecodist::distance(gems_mtx, 'jaccard')),   'ecodive'      = cleanup(ecodive::jaccard(gems_mtx)),   'parallelDist' = cleanup(parallelDist::parallelDist(gems_mtx, 'binary')),   'philentropy'  = cleanup(philentropy::distance(gems_mtx > 0, 'jaccard', test.na = FALSE, use.row.names = TRUE, as.dist.obj = TRUE, mute.message = TRUE)),   'phyloregion'  = cleanup(phyloregion::beta_diss(gems_mtx, 'jaccard')$beta.jac),   'stats'        = cleanup(stats::dist(gems_mtx, 'binary')),   'vegan'        = cleanup(vegan::vegdist(gems_mtx, 'jaccard', binary = TRUE)) )   ## Manhattan Distance manhattan_res <- bench::mark(   iterations = 10,   'abdiv'        = cleanup(pairwise(abdiv::manhattan, gems_mtx)),   'ecodist'      = cleanup(ecodist::distance(gems_mtx, 'manhattan')),   'ecodive'      = cleanup(ecodive::manhattan(gems_mtx, norm = 'none')),   'parallelDist' = cleanup(parallelDist::parallelDist(gems_mtx, 'manhattan')),   'philentropy'  = cleanup(philentropy::distance(gems_mtx, 'manhattan', test.na = FALSE, use.row.names = TRUE, as.dist.obj = TRUE, mute.message = TRUE)),   'stats'        = cleanup(stats::dist(gems_mtx, 'manhattan')),   'vegan'        = cleanup(vegan::vegdist(gems_mtx, 'manhattan')) )   ## Euclidean Distance euclidean_res <- bench::mark(   iterations = 10,   'abdiv'        = cleanup(pairwise(abdiv::euclidean, gems_mtx)),   'ecodist'      = cleanup(ecodist::distance(gems_mtx, 'euclidean')),   'ecodive'      = cleanup(ecodive::euclidean(gems_mtx, norm = 'none')),   'parallelDist' = cleanup(parallelDist::parallelDist(gems_mtx, 'euclidean')),   'philentropy'  = cleanup(philentropy::distance(gems_mtx, 'euclidean', test.na = FALSE, use.row.names = TRUE, as.dist.obj = TRUE, mute.message = TRUE)),   'stats'        = cleanup(stats::dist(gems_mtx, 'euclidean')),   'vegan'        = cleanup(vegan::vegdist(gems_mtx, 'euclidean')) )   ## Shannon Diversity Index shannon_res <- bench::mark(   iterations  = 10,   'abdiv'       = apply(gems_mtx, 1L, abdiv::shannon),   'adiv'        = adiv::speciesdiv(gems_mtx, 'Shannon')[,1],   'ecodive'     = ecodive::shannon(gems_mtx),   'entropart'   = apply(gems_mtx, 1L, entropart::Shannon, CheckArguments = FALSE),   'philentropy' = apply(gems_mtx, 1L, philentropy::H, unit = 'log'),   'tabula'      = apply(gems_mtx, 1L, tabula::index_shannon),   'vegan'       = vegan::diversity(gems_mtx, 'shannon') )   ## Gini-Simpson Index simpson_res <- bench::mark(   iterations  = 10,   'abdiv'     = apply(gems_mtx, 1L, abdiv::simpson),   'adiv'      = adiv::speciesdiv(gems_mtx, 'GiniSimpson')[,1],   'ecodive'   = ecodive::simpson(gems_mtx),   'entropart' = apply(gems_mtx, 1L, entropart::Simpson, CheckArguments = FALSE),   'tabula'    = 1 - apply(gems_mtx, 1L, tabula::index_simpson),   'vegan'     = vegan::diversity(gems_mtx, 'simpson') )   ## Faith's Phylogenetic Diversity faith_res <- bench::mark(   iterations    = 10,   check         = FALSE, # entropart has incorrect output on non-ultrametric tree   'abdiv'       = apply(hmp50_mtx, 1L, abdiv::faith_pd, hmp50_tree),   'adiv'        = apply(hmp50_mtx, 1L, \\(x) adiv::EH(hmp50_tree, colnames(hmp50_mtx)[x > 0])),   'ecodive'     = ecodive::faith(hmp50_mtx, hmp50_tree),   'entropart'   = apply(hmp50_mtx, 1L, entropart::PDFD, hmp50_tree, CheckArguments = FALSE),   'phyloregion' = phyloregion::PD(hmp50_mtx, hmp50_tree),   'picante'     = as.matrix(picante::pd(hmp50_mtx, hmp50_tree))[,'PD'] )     ## Unweighted UniFrac u_unifrac_res <- rbind(      local({     # cluster for phyloseq     cl <- parallel::makeCluster(n_cpus)     doParallel::registerDoParallel(cl)     on.exit(parallel::stopCluster(cl))          bench::mark(       iterations    = 10,       'abdiv'       = cleanup(pairwise(abdiv::unweighted_unifrac, hmp50_mtx, hmp50_tree)),       'ecodive'     = cleanup(ecodive::unweighted_unifrac(hmp50_mtx, hmp50_tree)),       'GUniFrac'    = cleanup(as.dist(GUniFrac::GUniFrac(hmp50_mtx, hmp50_tree, alpha=1, verbose=FALSE)[[1]][,,2])),       'phyloregion' = cleanup(phyloregion::unifrac(hmp50_mtx, hmp50_tree)),       'phyloseq'    = cleanup(phyloseq::UniFrac(hmp50_phy, weighted=FALSE, normalized=FALSE, parallel=TRUE)),       'picante'     = cleanup(picante::unifrac(hmp50_mtx, hmp50_tree)) )   }),      # ampvis2 conflicts with phyloseq cluster, so run separately   local({     t_hmp50_mtx <- t(hmp50_mtx)     bench::mark(       iterations = 10,       'ampvis2'  = {         cleanup(ampvis2:::dist.unifrac(t_hmp50_mtx, hmp50_tree, weighted=FALSE, normalise=FALSE, num_threads=n_cpus))         doParallel::stopImplicitCluster() } )   }) )       ## Weighted UniFrac w_unifrac_res <- rbind(      local({     # cluster for phyloseq     cl <- parallel::makeCluster(n_cpus)     doParallel::registerDoParallel(cl)     on.exit(parallel::stopCluster(cl))          bench::mark(       iterations = 10,       'abdiv'    = cleanup(pairwise(abdiv::weighted_unifrac, hmp50_mtx, hmp50_tree)),       'ecodive'  = cleanup(ecodive::weighted_unifrac(hmp50_mtx, hmp50_tree)),       'phyloseq' = cleanup(phyloseq::UniFrac(hmp50_phy, weighted=TRUE, normalized=FALSE, parallel=TRUE)) )   }),      # ampvis2 conflicts with phyloseq cluster, so run separately   local({     t_hmp50_mtx <- t(hmp50_mtx)     bench::mark(       iterations = 10,       'ampvis2'  = {         cleanup(ampvis2:::dist.unifrac(t_hmp50_mtx, hmp50_tree, weighted=TRUE, normalise=FALSE, num_threads=n_cpus))         doParallel::stopImplicitCluster() } )   }) )   ## Weighted Normalized UniFrac wn_unifrac_res <- rbind(      local({     # cluster for phyloseq     cl <- parallel::makeCluster(n_cpus)     doParallel::registerDoParallel(cl)     on.exit(parallel::stopCluster(cl))          bench::mark(       iterations = 10,       'abdiv'    = cleanup(pairwise(abdiv::weighted_normalized_unifrac, hmp50_mtx, hmp50_tree)),       'ecodive'  = cleanup(ecodive::normalized_unifrac(hmp50_mtx, hmp50_tree)),       'GUniFrac' = cleanup(as.dist(GUniFrac::GUniFrac(hmp50_mtx, hmp50_tree, alpha=1, verbose=FALSE)[[1]][,,1])),       'phyloseq' = cleanup(phyloseq::UniFrac(hmp50_phy, weighted=TRUE, normalized=TRUE, parallel=TRUE)) )   }),      # ampvis2 conflicts with phyloseq cluster, so run separately   local({     t_hmp50_mtx <- t(hmp50_mtx)     bench::mark(       iterations = 10,       'ampvis2'  = {         cleanup(ampvis2:::dist.unifrac(t_hmp50_mtx, hmp50_tree, weighted=TRUE, normalise=TRUE, num_threads=n_cpus))         doParallel::stopImplicitCluster() } )   }) )   ## Weighted Normalized UniFrac g_unifrac_res <- rbind(      local({     # cluster for phyloseq     cl <- parallel::makeCluster(n_cpus)     doParallel::registerDoParallel(cl)     on.exit(parallel::stopCluster(cl))          bench::mark(       iterations = 10,       'abdiv'    = cleanup(pairwise(abdiv::generalized_unifrac, hmp50_mtx, hmp50_tree, alpha=0.5)),       'ecodive'  = cleanup(ecodive::generalized_unifrac(hmp50_mtx, hmp50_tree, alpha=0.5)),       'GUniFrac' = cleanup(as.dist(GUniFrac::GUniFrac(hmp50_mtx, hmp50_tree, alpha=0.5, verbose=FALSE)[[1]][,,1])) )   }) )   ## Variance Adjusted UniFrac va_unifrac_res <- rbind(      local({     # cluster for phyloseq     cl <- parallel::makeCluster(n_cpus)     doParallel::registerDoParallel(cl)     on.exit(parallel::stopCluster(cl))          bench::mark(       iterations = 10,       'abdiv'    = cleanup(pairwise(abdiv::variance_adjusted_unifrac, hmp50_mtx, hmp50_tree)),       'ecodive'  = cleanup(ecodive::variance_adjusted_unifrac(hmp50_mtx, hmp50_tree)) )   }) )     ## Data frame for Figure 1A Fig1A_data <- bind_rows(     mutate(bray_curtis_res, Metric = 'bray'),     mutate(shannon_res,     Metric = 'shannon'),     mutate(faith_res,       Metric = 'faith') ) %>%   mutate(Package = as.character(expression)) %>%   select(Package, Metric, median, mem_alloc) %>%   arrange(Metric, median)  Fig1A_data$Title <- factor(   x      = Fig1A_data$Metric,    levels = c(\"shannon\", \"bray\", \"faith\"),    labels = c(     \"**Shannon Diversity Index**<br>1006 samples\",      \"**Bray-Curtis Dissimilarity**<br>1006 samples\",      \"**Faith's Phylogenetic Diversity**<br>50 samples\") )   ## ggplot for Figure 1A Fig1A <- ggplot(Fig1A_data, aes(x = median, y = mem_alloc)) +     facet_wrap('Title', nrow = 1, scales = 'free_x') +      geom_point() +     geom_label_repel(aes(         label    = Package,         alpha    = ifelse(Package == 'ecodive', 1, 0.6),         fontface = ifelse(Package == 'ecodive', 2, 1),         size     = ifelse(Package == 'ecodive', 3.2, 3) ),        box.padding        = .4,       point.padding      = .5,       min.segment.length = 0 ) +      scale_alpha_identity(guide = 'none') +     scale_size_identity(guide = 'none') +     bench::scale_x_bench_time() +     scale_y_log10(labels = scales::label_bytes()) +     labs(       tag = 'A',       x   = 'Median Calculation Time (log scale; n=10)',        y   = 'Memory Allocated\\n(log scale; n=1)' ) +     theme_bw(base_size = 12) +     theme(       strip.text   = ggtext::element_markdown(hjust = 0, lineheight = 1.2),       axis.title.x = element_text(margin = margin(t = 10)))         ## Data frame for Figure 1B Fig1B_data <- bind_rows(     mutate(u_unifrac_res,  `UniFrac Variant` = 'Unweighted'),     mutate(w_unifrac_res,  `UniFrac Variant` = 'Weighted'),     mutate(wn_unifrac_res, `UniFrac Variant` = 'Weighted Normalized'),     mutate(g_unifrac_res,  `UniFrac Variant` = 'Generalized'),     mutate(va_unifrac_res, `UniFrac Variant` = 'Variance Adjusted') ) %>%   mutate(Package = as.character(expression)) %>%   select(Package, `UniFrac Variant`, median, mem_alloc) %>%   arrange(Package)  Fig1B_data$Title <- \"**UniFrac Family**<br>50 samples\" Fig1B_data$`UniFrac Variant` <- factor(   x      = Fig1B_data$`UniFrac Variant`,    levels = c(\"Unweighted\", \"Weighted\", \"Weighted Normalized\", \"Generalized\", \"Variance Adjusted\") )   ## ggplot for Figure 1B Fig1B <- ggplot(Fig1B_data, aes(x = median, y = mem_alloc)) +   facet_wrap('Title') +    geom_point(aes(shape = `UniFrac Variant`), size = 2) +   geom_label_repel(aes(       label    = Package,        alpha    = ifelse(Package == 'ecodive', 1, 0.6),       fontface = ifelse(Package == 'ecodive', 2, 1),       size     = ifelse(Package == 'ecodive', 3.2, 3) ),     data          = ~subset(., `UniFrac Variant` == 'Unweighted'),     direction     = 'y',      box.padding   = 0.4,     point.padding = 10,     min.segment.length = Inf ) +    scale_shape(solid = FALSE) +    scale_alpha_identity(guide = 'none') +   scale_size_identity(guide = 'none') +   bench::scale_x_bench_time() +   scale_y_log10(labels = scales::label_bytes()) +   labs(     tag = 'B',     x   = 'Median Calculation Time (log scale; n=10)',      y   = 'Memory Allocated\\n(log scale; n=1)' ) +   theme_bw(base_size = 12) +   theme(     strip.text   = ggtext::element_markdown(hjust = 0, lineheight = 1.2),     axis.title.x = element_text(margin = margin(t = 10)) )   ## Combined Figure 1 Fig1 <- patchwork::wrap_plots(   Fig1A,    Fig1B,    patchwork::guide_area(),    design = \"111\\n223\",    guides = 'collect' )"},{"path":"https://cmmr.github.io/ecodive/articles/benchmark.html","id":"results","dir":"Articles","previous_headings":"","what":"Results","title":"Benchmarks","text":"","code":"print(Fig1)"},{"path":"https://cmmr.github.io/ecodive/articles/benchmark.html","id":"how-much-faster-and-more-memory-efficient-is-ecodive","dir":"Articles","previous_headings":"Results","what":"How much faster and more memory efficient is ecodive?","title":"Benchmarks","text":"","code":"plyr::ddply(Fig1A_data, as.name('Metric'), function (x) {   x[['median']]    <- as.numeric(x[['median']])   x[['mem_alloc']] <- as.numeric(x[['mem_alloc']])   ecodive <- as.list(x[x[['Package']] == 'ecodive',])   x       <- x[x[['Package']] != 'ecodive',]   data.frame(     speed  = paste0(paste(collapse=' - ', round(range(x$median    / ecodive$median))), 'x'),     memory = paste0(paste(collapse=' - ', round(range(x$mem_alloc / ecodive$mem_alloc))), 'x') ) }) #>    Metric      speed       memory #> 1    bray   1 - 166x    2 - 5312x #> 2   faith 1 - 10413x 212 - 74389x #> 3 shannon   2 - 113x      6 - 22x   plyr::ddply(Fig1B_data, as.name('UniFrac Variant'), function (x) {   x[['median']]    <- as.numeric(x[['median']])   x[['mem_alloc']] <- as.numeric(x[['mem_alloc']])   ecodive <- as.list(x[x[['Package']] == 'ecodive',])   x       <- x[x[['Package']] != 'ecodive',]   data.frame(     speed  = paste0(paste(collapse=' - ', round(range(x$median    / ecodive$median))), 'x'),     memory = paste0(paste(collapse=' - ', round(range(x$mem_alloc / ecodive$mem_alloc))), 'x') ) }) #>       UniFrac Variant        speed         memory #> 1          Unweighted    1 - 2251x    98 - 39485x #> 2            Weighted   44 - 2094x   178 - 74013x #> 3 Weighted Normalized   11 - 1991x   178 - 74049x #> 4         Generalized   10 - 1814x   310 - 69563x #> 5   Variance Adjusted 2353 - 2353x 90421 - 90421x"},{"path":"https://cmmr.github.io/ecodive/articles/benchmark.html","id":"raw-data-for-figure-1-panel-a","dir":"Articles","previous_headings":"Results","what":"Raw Data for Figure 1 Panel A","title":"Benchmarks","text":"","code":"print(Fig1A_data[,1:4], n = Inf) #> # A tibble: 21 × 4 #>    Package      Metric    median mem_alloc #>    <chr>        <chr>   <bch:tm> <bch:byt> #>  1 ecodive      bray    149.79ms    3.94MB #>  2 parallelDist bray    187.72ms    7.88MB #>  3 ecodist      bray    398.33ms   29.43MB #>  4 labdsv       bray    726.73ms   68.16MB #>  5 vegan        bray       1.69s   16.45MB #>  6 philentropy  bray      10.31s   14.66GB #>  7 abdiv        bray      13.75s   20.43GB #>  8 tabula       bray      24.89s   20.43GB #>  9 ecodive      faith     2.62ms  337.58KB #> 10 phyloregion  faith     3.08ms  141.47MB #> 11 picante      faith       77ms   69.86MB #> 12 abdiv        faith   476.24ms  651.64MB #> 13 adiv         faith      1.72s  489.05MB #> 14 entropart    faith     27.27s   23.95GB #> 15 ecodive      shannon  11.16ms    6.06MB #> 16 tabula       shannon  25.34ms    36.6MB #> 17 entropart    shannon  40.73ms   41.77MB #> 18 adiv         shannon   46.8ms  131.49MB #> 19 vegan        shannon  68.58ms   68.08MB #> 20 abdiv        shannon  85.22ms   95.41MB #> 21 philentropy  shannon    1.26s   52.78MB"},{"path":"https://cmmr.github.io/ecodive/articles/benchmark.html","id":"raw-data-for-figure-1-panel-b","dir":"Articles","previous_headings":"Results","what":"Raw Data for Figure 1 Panel B","title":"Benchmarks","text":"","code":"print(Fig1B_data[,1:4], n = Inf) #> # A tibble: 21 × 4 #>    Package     `UniFrac Variant`     median mem_alloc #>    <chr>       <fct>               <bch:tm> <bch:byt> #>  1 GUniFrac    Unweighted           86.15ms   113.4MB #>  2 GUniFrac    Weighted Normalized  78.51ms    92.1MB #>  3 GUniFrac    Generalized           75.7ms    92.1MB #>  4 abdiv       Unweighted               15s    20.1GB #>  5 abdiv       Weighted              13.67s      20GB #>  6 abdiv       Weighted Normalized   13.78s      20GB #>  7 abdiv       Generalized           13.78s    20.2GB #>  8 abdiv       Variance Adjusted     15.81s    24.5GB #>  9 ampvis2     Unweighted             3.64s    53.7MB #> 10 ampvis2     Weighted                3.2s    49.2MB #> 11 ampvis2     Weighted Normalized    3.33s    49.3MB #> 12 ecodive     Unweighted            6.66ms   532.6KB #> 13 ecodive     Weighted              6.53ms   283.7KB #> 14 ecodive     Weighted Normalized   6.92ms   283.7KB #> 15 ecodive     Generalized           7.59ms   304.3KB #> 16 ecodive     Variance Adjusted     6.72ms   283.7KB #> 17 phyloregion Unweighted             7.1ms   145.9MB #> 18 phyloseq    Unweighted          325.11ms    50.9MB #> 19 phyloseq    Weighted            288.33ms    49.4MB #> 20 phyloseq    Weighted Normalized 296.54ms    49.5MB #> 21 picante     Unweighted             2.56s     1.8GB"},{"path":"https://cmmr.github.io/ecodive/articles/ecodive.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Introduction to ecodive","text":"Ecodive calculates ecological diversity metrics. Alpha diversity metrics provide insight single sample’s diversity, whereas beta diversity metrics indicate different pair samples . guide, ’ll use ex_counts dataset included ecodive. ex_counts feature table enumerates many times bacterial genera observed different body sites. example, ‘features’ feature table genera. However, dataset can use whatever feature makes sense - species, OTUs, ASVs, even something completely unrelated ecology.","code":"library(ecodive)  t(ex_counts) #>                   Saliva Gums Nose Stool #> Streptococcus        162  793   22     1 #> Bacteroides            2    4    2   611 #> Corynebacterium        0    0  498     1 #> Haemophilus          180   87    2     1 #> Propionibacterium      1    1  251     0 #> Staphylococcus         0    1  236     1"},{"path":"https://cmmr.github.io/ecodive/articles/ecodive.html","id":"alpha-diversity","dir":"Articles","previous_headings":"","what":"Alpha Diversity","title":"Introduction to ecodive","text":"Alpha diversity metrics describe many different genera present sample. Depending metric, can take account number unique genera (richness), evenly population split among genera (evenness), distantly related genera (phylogenetic diversity). available alpha diversity metrics can listed using list_metrics(). reading: vignette('adiv')","code":"list_metrics('alpha')[,1:5] #>                                        name          id phylo weighted int_only #> 1  Abundance-based Coverage Estimator (ACE)         ace FALSE     TRUE     TRUE #> 3                       Berger-Parker Index      berger FALSE     TRUE    FALSE #> 6                           Brillouin Index   brillouin FALSE     TRUE     TRUE #> 8                                     Chao1       chao1 FALSE     TRUE     TRUE #> 15           Faith's Phylogenetic Diversity       faith  TRUE    FALSE    FALSE #> 16                           Fisher's Alpha      fisher FALSE     TRUE     TRUE #> 18                       Gini-Simpson Index     simpson FALSE     TRUE    FALSE #> 23                    Inverse Simpson Index inv_simpson FALSE     TRUE    FALSE #> 29                Margalef's Richness Index    margalef FALSE     TRUE     TRUE #> 31                           McIntosh Index    mcintosh FALSE     TRUE     TRUE #> 32               Menhinick's Richness Index   menhinick FALSE     TRUE     TRUE #> 37                        Observed Features    observed FALSE    FALSE    FALSE #> 40                  Shannon Diversity Index     shannon FALSE     TRUE    FALSE #> 45               Squares Richness Estimator     squares FALSE     TRUE     TRUE"},{"path":"https://cmmr.github.io/ecodive/articles/ecodive.html","id":"beta-diversity","dir":"Articles","previous_headings":"","what":"Beta Diversity","title":"Introduction to ecodive","text":"Beta diversity metrics describe different two samples , based genera observed .UniFrac metrics incorporate phylogenetic tree calculation. available alpha diversity metrics can listed using list_metrics().","code":"list_metrics('beta')[,2:6] #>                           id phylo weighted int_only true_metric #> 2                  aitchison FALSE     TRUE    FALSE        TRUE #> 4              bhattacharyya FALSE     TRUE    FALSE        TRUE #> 5                       bray FALSE     TRUE    FALSE       FALSE #> 7                   canberra FALSE     TRUE    FALSE        TRUE #> 9                  chebyshev FALSE     TRUE    FALSE        TRUE #> 10                     chord FALSE     TRUE    FALSE        TRUE #> 11                     clark FALSE     TRUE    FALSE        TRUE #> 12                  sorensen FALSE    FALSE    FALSE       FALSE #> 13                divergence FALSE     TRUE    FALSE        TRUE #> 14                 euclidean FALSE     TRUE    FALSE        TRUE #> 17       generalized_unifrac  TRUE     TRUE    FALSE        TRUE #> 19                     gower FALSE     TRUE    FALSE        TRUE #> 20                   hamming FALSE    FALSE    FALSE        TRUE #> 21                 hellinger FALSE     TRUE    FALSE        TRUE #> 22                      horn FALSE     TRUE    FALSE       FALSE #> 24                   jaccard FALSE    FALSE    FALSE        TRUE #> 25                    jensen FALSE     TRUE    FALSE        TRUE #> 26                       jsd FALSE     TRUE    FALSE        TRUE #> 27                lorentzian FALSE     TRUE    FALSE       FALSE #> 28                 manhattan FALSE     TRUE    FALSE        TRUE #> 30                  matusita FALSE     TRUE    FALSE        TRUE #> 33                 minkowski FALSE     TRUE    FALSE        TRUE #> 34                  morisita FALSE     TRUE     TRUE       FALSE #> 35                    motyka FALSE     TRUE    FALSE       FALSE #> 36        normalized_unifrac  TRUE     TRUE    FALSE        TRUE #> 38                    ochiai FALSE    FALSE    FALSE       FALSE #> 39                psym_chisq FALSE     TRUE    FALSE       FALSE #> 41                   soergel FALSE     TRUE    FALSE        TRUE #> 42             squared_chisq FALSE     TRUE    FALSE       FALSE #> 43             squared_chord FALSE     TRUE    FALSE       FALSE #> 44         squared_euclidean FALSE     TRUE    FALSE       FALSE #> 46                    topsoe FALSE     TRUE    FALSE        TRUE #> 47        unweighted_unifrac  TRUE     TRUE    FALSE        TRUE #> 48 variance_adjusted_unifrac  TRUE     TRUE    FALSE        TRUE #> 49               wave_hedges FALSE     TRUE    FALSE       FALSE #> 50          weighted_unifrac  TRUE     TRUE    FALSE        TRUE"},{"path":[]},{"path":"https://cmmr.github.io/ecodive/articles/ecodive.html","id":"rarefaction","dir":"Articles","previous_headings":"Example","what":"Rarefaction","title":"Introduction to ecodive","text":"ex_counts feature table 345 saliva observations, nose 1011 observations. unequal sampling depth can cause systematic biases. Specifically, rare genera observed often samples greater sampling depths, thereby artificially inflating observed richness. first step rarefy ex_counts samples number observations. Rarefying randomly removes observations samples observations.","code":"rowSums(ex_counts) #> Saliva   Gums   Nose  Stool  #>    345    886   1011    615   counts <- rarefy(ex_counts)  rowSums(counts) #> Saliva   Gums   Nose  Stool  #>    345    345    345    345   t(counts) #>                   Saliva Gums Nose Stool #> Streptococcus        162  309    6     1 #> Bacteroides            2    2    0   341 #> Corynebacterium        0    0  171     1 #> Haemophilus          180   34    0     1 #> Propionibacterium      1    0   82     0 #> Staphylococcus         0    0   86     1"},{"path":"https://cmmr.github.io/ecodive/articles/ecodive.html","id":"classic-metrics","dir":"Articles","previous_headings":"Example","what":"Classic Metrics","title":"Introduction to ecodive","text":"alpha beta diversity metrics around 50+ years don’t require phylogenetic tree. beta diversity functions can take weighted = FALSE argument use presence/absence information instead relative abundances.","code":"## Alpha Diversity -------------------  shannon(counts) #>     Saliva       Gums       Nose      Stool  #> 0.74119910 0.35692121 1.10615349 0.07927797    ## Beta Diversity --------------------  bray(counts) #>          Saliva      Gums      Nose #> Gums  0.4260870                     #> Nose  0.9797101 0.9826087           #> Stool 0.9884058 0.9884058 0.9913043"},{"path":"https://cmmr.github.io/ecodive/articles/ecodive.html","id":"phylogenetic-metrics","dir":"Articles","previous_headings":"Example","what":"Phylogenetic Metrics","title":"Introduction to ecodive","text":"phylogenetic tree enables alpha beta diversity metrics take account evolutionary relatedness observed genera, generally giving higher diversity values samples distantly related genera. Faith (alpha diversity) UniFrac (beta diversity) examples phylogenetic metrics. ex_tree object included ecodive provides phylogenetic tree genera ex_counts. datasets, can use ecodive’s read_tree() function import phylogenetic tree newick formatted string file.","code":"## Alpha Diversity -------------------  faith(counts, tree = ex_tree) #> Saliva   Gums   Nose  Stool  #>    180    155    101    202    ## Beta Diversity --------------------  normalized_unifrac(counts, tree = ex_tree) #>          Saliva      Gums      Nose #> Gums  0.4328662                     #> Nose  0.7928701 0.6767840           #> Stool 0.9677535 0.9829736 0.9936121"},{"path":"https://cmmr.github.io/ecodive/articles/ecodive.html","id":"distance-matrices","dir":"Articles","previous_headings":"Example","what":"Distance Matrices","title":"Introduction to ecodive","text":"Beta diversity functions return dist object. can convert standard R matrix .matrix() function.","code":"dm <- bray(counts) dm #>          Saliva      Gums      Nose #> Gums  0.1428571                     #> Nose  0.5000000 0.7142857           #> Stool 0.3333333 0.2500000 0.3333333  mtx <- as.matrix(dm) mtx #>           Saliva      Gums      Nose     Stool #> Saliva 0.0000000 0.1428571 0.5000000 0.3333333 #> Gums   0.1428571 0.0000000 0.7142857 0.2500000 #> Nose   0.5000000 0.7142857 0.0000000 0.3333333 #> Stool  0.3333333 0.2500000 0.3333333 0.0000000  mtx['Saliva', 'Nose'] #> [1] 0.5"},{"path":"https://cmmr.github.io/ecodive/articles/unifrac.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"UniFrac Calculations","text":"different UniFrac algorithms listed , along examples calculating .","code":""},{"path":"https://cmmr.github.io/ecodive/articles/unifrac.html","id":"input-data","dir":"Articles","previous_headings":"","what":"Input Data","title":"UniFrac Calculations","text":"numeric matrix two samples five species. phylogenetic tree five species.","code":""},{"path":"https://cmmr.github.io/ecodive/articles/unifrac.html","id":"definitions","dir":"Articles","previous_headings":"","what":"Definitions","title":"UniFrac Calculations","text":"branch indices (green circles) used ordering L, , B arrays. Values L drawn input phylogenetic tree. Values B total number species observations descending branch; Sample_A, B Sample_B.","code":""},{"path":"https://cmmr.github.io/ecodive/articles/unifrac.html","id":"unweighted","dir":"Articles","previous_headings":"","what":"Unweighted","title":"UniFrac Calculations","text":"Lozupone et al, 2005: Unweighted UniFrac R Package ecodive: unweighted_unifrac() R Package abdiv: unweighted_unifrac() R Package phyloseq: UniFrac(weighted=FALSE) qiime2 qiime diversity beta-phylogenetic --p-metric unweighted_unifrac mothur: unifrac.unweighted() First, transform B presence (1) absence (0) indicators. \\begin{align*}  &= \\{9, 0, 0, 0, 9, 6, 3, 3\\} \\\\ ' &= \\{1, 0, 0, 0, 1, 1, 1, 1\\} \\end{align*} \\begin{align*} B  &= \\{7, 5, 1, 4, 2, 8, 8, 0\\} \\\\ B' &= \\{1, 1, 1, 1, 1, 1, 1, 0\\} \\end{align*} apply formula: \\begin{align*} U &= \\displaystyle \\frac{\\sum_{= 1}^{n} L_i(|'_i - B'_i|)}{\\sum_{= 1}^{n} L_i(max('_i,B'_i))}  \\\\ \\\\ U &= \\displaystyle \\frac{L_1(|'_1-B'_1|) + L_2(|'_2-B'_2|) + \\cdots + L_n(|'_n-B'_n|)}{L_1(max('_1,B'_1)) + L_2(max('_2,B'_2)) + \\cdots + L_n(max('_n,B'_n))}  \\\\ \\\\ U &= \\displaystyle \\frac{0.2(|1-1|) + 0.4(|0-1|) + \\cdots + 0.3(|1-0|)}{0.2(max(1,1)) + 0.4(max(0,1)) + \\cdots + 0.3(max(1,0))}  \\\\ \\\\ U &= \\displaystyle \\frac{0.2(0) + 0.4(1) + 0.8(1) + 0.5(1) + 0.9(0) + 0.6(0) + 0.7(0) + 0.3(1)}{0.2(1) + 0.4(1) + 0.8(1) + 0.5(1) + 0.9(1) + 0.6(1) + 0.7(1) + 0.3(1)}  \\\\ \\\\ U &= \\displaystyle \\frac{0.4 + 0.8 + 0.5 + 0.3}{0.2 + 0.4 + 0.8 + 0.5 + 0.9 + 0.6 + 0.7 + 0.3}  \\\\ \\\\ U &= \\displaystyle \\frac{2}{4.4}  \\\\ \\\\ U &= 0.4545455 \\end{align*}","code":""},{"path":"https://cmmr.github.io/ecodive/articles/unifrac.html","id":"weighted","dir":"Articles","previous_headings":"","what":"Weighted","title":"UniFrac Calculations","text":"Lozupone et al, 2007: Raw Weighted UniFrac R Package ecodive: weighted_unifrac() R Package abdiv: weighted_unifrac() R Package phyloseq: UniFrac(weighted=TRUE, normalized=FALSE) qiime2 qiime diversity beta-phylogenetic --p-metric weighted_unifrac \\begin{align*} W &= \\sum_{= 1}^{n} L_i|\\frac{A_i}{A_T} - \\frac{B_i}{B_T}|  \\\\ \\\\ W &= L_1|\\frac{A_1}{A_T} - \\frac{B_1}{B_T}| + L_2|\\frac{A_2}{A_T} - \\frac{B_2}{B_T}| + \\cdots + L_n|\\frac{A_n}{A_T} - \\frac{B_n}{B_T}|  \\\\ \\\\ W &= 0.2|\\frac{9}{15} - \\frac{7}{15}| + 0.4|\\frac{0}{15} - \\frac{5}{15}| + \\cdots + 0.3|\\frac{3}{15} - \\frac{0}{15}|  \\\\ \\\\ W &= 0.02\\overline{6} + 0.1\\overline{3} + 0.05\\overline{3} + 0.1\\overline{3} + 0.42 + 0.08 + 0.2\\overline{3} + 0.06  \\\\ \\\\ W &= 1.14 \\end{align*}","code":""},{"path":"https://cmmr.github.io/ecodive/articles/unifrac.html","id":"normalized","dir":"Articles","previous_headings":"","what":"Normalized","title":"UniFrac Calculations","text":"Lozupone et al, 2007: Normalized Weighted UniFrac R Package ecodive: normalized_unifrac() R Package abdiv: weighted_normalized_unifrac() R Package phyloseq: UniFrac(weighted=TRUE, normalized=TRUE) qiime2 qiime diversity beta-phylogenetic --p-metric weighted_normalized_unifrac mothur: unifrac.weighted() \\begin{align*}  N &= \\displaystyle \\frac   {\\sum_{= 1}^{n} L_i|\\frac{A_i}{A_T} - \\frac{B_i}{B_T}|}   {\\sum_{= 1}^{n} L_i(\\frac{A_i}{A_T} + \\frac{B_i}{B_T})}   \\\\ \\\\    N &= \\displaystyle \\frac   {L_1|\\frac{A_1}{A_T} - \\frac{B_1}{B_T}| + L_2|\\frac{A_2}{A_T} - \\frac{B_2}{B_T}| + \\cdots + L_n|\\frac{A_n}{A_T} - \\frac{B_n}{B_T}|}   {L_1(\\frac{A_1}{A_T} + \\frac{B_1}{B_T}) + L_2(\\frac{A_2}{A_T} + \\frac{B_2}{B_T}) + \\cdots + L_n(\\frac{A_n}{A_T} + \\frac{B_n}{B_T})}   \\\\ \\\\    N &= \\displaystyle \\frac   {0.2|\\frac{9}{15} - \\frac{7}{15}| + 0.4|\\frac{0}{15} - \\frac{5}{15}| + \\cdots + 0.3|\\frac{3}{15} - \\frac{0}{15}|}   {0.2(\\frac{9}{15} + \\frac{7}{15}) + 0.4(\\frac{0}{15} + \\frac{5}{15}) + \\cdots + 0.3(\\frac{3}{15} + \\frac{0}{15})}   \\\\ \\\\    N &= \\displaystyle \\frac   {0.02\\overline{6} + 0.1\\overline{3} + 0.05\\overline{3} + 0.1\\overline{3} + 0.42 + 0.08 + 0.2\\overline{3} + 0.06}   {0.21\\overline{3} + 0.1\\overline{3} + 0.05\\overline{3} + 0.1\\overline{3} + 0.66 + 0.56 + 0.51\\overline{3} + 0.06}   \\\\ \\\\    N &= \\displaystyle \\frac{1.14}{2.326667}  \\\\ \\\\ N &= 0.4899713 \\end{align*}","code":""},{"path":"https://cmmr.github.io/ecodive/articles/unifrac.html","id":"generalized","dir":"Articles","previous_headings":"","what":"Generalized","title":"UniFrac Calculations","text":"Chen et al. 2012: Generalized UniFrac R Package ecodive: generalized_unifrac(alpha = 0.5) R Package abdiv: generalized_unifrac(alpha = 0.5) R Package GUniFrac: GUniFrac(alpha = 0.5) qiime2 qiime diversity beta-phylogenetic --p-metric generalized_unifrac -0.5 \\begin{align*}  G &= \\displaystyle \\frac   {\\sum_{= 1}^{n} L_i(\\frac{A_i}{A_T} + \\frac{B_i}{B_T})^{\\alpha}     |\\displaystyle \\frac       {\\frac{A_i}{A_T} - \\frac{B_i}{B_T}}       {\\frac{A_i}{A_T} + \\frac{B_i}{B_T}} |}   {\\sum_{= 1}^{n} L_i(\\frac{A_i}{A_T} + \\frac{B_i}{B_T})^{\\alpha}}  \\\\ \\\\  G &= \\displaystyle \\frac   {     L_1(\\frac{A_1}{A_T} + \\frac{B_1}{B_T})^{0.5}       |\\displaystyle \\frac         {\\frac{A_1}{A_T} - \\frac{B_1}{B_T}}         {\\frac{A_1}{A_T} + \\frac{B_1}{B_T}}| +     \\cdots +     L_n(\\frac{A_n}{A_T} + \\frac{B_n}{B_T})^{0.5}       |\\displaystyle \\frac         {\\frac{A_n}{A_T} - \\frac{B_n}{B_T}}         {\\frac{A_n}{A_T} + \\frac{B_n}{B_T}}|   }{     L_1(\\frac{A_1}{A_T} + \\frac{B_1}{B_T})^{0.5} +     \\cdots +     L_n(\\frac{A_n}{A_T} + \\frac{B_n}{B_T})^{0.5}   }     \\\\ \\\\  G &= \\displaystyle \\frac   {     0.2(\\frac{9}{15} + \\frac{7}{15})^{0.5}       |\\displaystyle \\frac         {\\frac{9}{15} - \\frac{7}{15}}         {\\frac{9}{15} + \\frac{7}{15}}| +     \\cdots +     0.3(\\frac{3}{15} + \\frac{0}{15})^{0.5}       |\\displaystyle \\frac         {\\frac{3}{15} - \\frac{0}{15}}         {\\frac{3}{15} + \\frac{0}{15}}|   }{     0.2(\\frac{9}{15} + \\frac{7}{15})^{0.5} +     \\cdots +     0.3(\\frac{3}{15} + \\frac{0}{15})^{0.5}   }     \\\\ \\\\    G &\\approx \\displaystyle \\frac   {0.03 + 0.23 + 0.21 + 0.26 + 0.49 + 0.08 + 0.27 + 0.13}   {0.21 + 0.23 + 0.21 + 0.26 + 0.77 + 0.58 + 0.60 + 0.13}   \\\\ \\\\    G &= \\displaystyle \\frac{1.701419}{2.986235}  \\\\ \\\\ G &= 0.569754  \\end{align*}","code":""},{"path":"https://cmmr.github.io/ecodive/articles/unifrac.html","id":"variance-adjusted","dir":"Articles","previous_headings":"","what":"Variance Adjusted","title":"UniFrac Calculations","text":"Chang et al, 2011: Variance Adjusted Weighted (VAW) UniFrac R Package ecodive: variance_adjusted_unifrac() R Package abdiv: variance_adjusted_unifrac() qiime2 qiime diversity beta-phylogenetic --p-metric weighted_normalized_unifrac --p-variance-adjusted \\begin{align*}  V &= \\displaystyle \\frac   {\\sum_{= 1}^{n} L_i\\displaystyle \\frac     {|\\frac{A_i}{A_T} - \\frac{B_i}{B_T}|}     {\\sqrt{(A_i + B_i)(A_T + B_T - A_i - B_i)}} }   {\\sum_{= 1}^{n} L_i\\displaystyle \\frac     {\\frac{A_i}{A_T} + \\frac{B_i}{B_T}}     {\\sqrt{(A_i + B_i)(A_T + B_T - A_i - B_i)}} }  \\\\ \\\\  V &= \\displaystyle \\frac   {     L_1\\displaystyle \\frac     {|\\frac{A_1}{A_T} - \\frac{B_1}{B_T}|}     {\\sqrt{(A_1 + B_1)(A_T + B_T - A_1 - B_1)}} +     \\cdots +     L_n\\displaystyle \\frac     {|\\frac{A_n}{A_T} - \\frac{B_n}{B_T}|}     {\\sqrt{(A_n + B_n)(A_T + B_T - A_n - B_n)}}   }{     L_1\\displaystyle \\frac     {\\frac{A_1}{A_T} + \\frac{B_1}{B_T}}     {\\sqrt{(A_1 + B_1)(A_T + B_T - A_1 - B_1)}} +     \\cdots +     L_n\\displaystyle \\frac     {\\frac{A_n}{A_T} + \\frac{B_n}{B_T}}     {\\sqrt{(A_n + B_n)(A_T + B_T - A_n - B_n)}}   }     \\\\ \\\\  V &= \\displaystyle \\frac   {     0.2\\displaystyle \\frac     {|\\frac{9}{15} - \\frac{7}{15}|}     {\\sqrt{(9 + 7)(15 + 15 - 9 - 7)}} +     \\cdots +     0.3\\displaystyle \\frac     {|\\frac{3}{15} - \\frac{0}{15}|}     {\\sqrt{(3 + 0)(15 + 15 - 3 - 0)}}   }{     0.2\\displaystyle \\frac     {\\frac{9}{15} + \\frac{7}{15}}     {\\sqrt{(9 + 7)(15 + 15 - 9 - 7)}} +     \\cdots +     0.3\\displaystyle \\frac     {\\frac{3}{15} + \\frac{0}{15}}     {\\sqrt{(3 + 0)(15 + 15 - 3 - 0)}}   }     \\\\ \\\\    V &\\approx \\displaystyle \\frac   {0.002 + 0.012 + 0.010 + 0.013 + 0.029 + 0.005 + 0.016 + 0.007}   {0.014 + 0.012 + 0.010 + 0.013 + 0.046 + 0.037 + 0.036 + 0.007}   \\\\ \\\\    V &= \\displaystyle \\frac{4.09389}{4.174402}  \\\\ \\\\ V &= 0.9807128  \\end{align*}","code":""},{"path":"https://cmmr.github.io/ecodive/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Daniel P. Smith. Author, maintainer. Alkek Center Metagenomics Microbiome Research. Copyright holder, funder.","code":""},{"path":"https://cmmr.github.io/ecodive/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Smith D (2025). ecodive: Parallel Memory-Efficient Ecological Diversity Metrics. R package version 2.1.0, https://cmmr.github.io/ecodive/.","code":"@Manual{,   title = {ecodive: Parallel and Memory-Efficient Ecological Diversity Metrics},   author = {Daniel P. Smith},   year = {2025},   note = {R package version 2.1.0},   url = {https://cmmr.github.io/ecodive/}, }"},{"path":"https://cmmr.github.io/ecodive/index.html","id":"ecodive-","dir":"","previous_headings":"","what":"Parallel and Memory-Efficient Ecological Diversity Metrics","title":"Parallel and Memory-Efficient Ecological Diversity Metrics","text":"ecodive R package calculating ecological diversity metrics parallelized memory-efficient manner. designed handle large datasets, common microbiome research.","code":""},{"path":"https://cmmr.github.io/ecodive/index.html","id":"why-ecodive","dir":"","previous_headings":"","what":"Why ecodive?","title":"Parallel and Memory-Efficient Ecological Diversity Metrics","text":"Analyzing ecological diversity often computational bottleneck, especially large datasets. ecodive addresses providing: High Performance: ecodive written C parallelized using pthreads, making dramatically faster R packages. Benchmarks show can 10,000x faster use 90,000x less memory. Zero Dependencies: package external R dependencies, making lightweight, stable, easy install. also makes ideal secure backend R packages. Comprehensive Metrics: implements wide range common alpha beta diversity metrics, including classic phylogenetic-aware methods like Faith’s PD complete UniFrac family. Ease Use: API simple integrates seamlessly popular bioinformatics packages like phyloseq rbiom.","code":""},{"path":"https://cmmr.github.io/ecodive/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Parallel and Memory-Efficient Ecological Diversity Metrics","text":"latest stable version can installed CRAN. development version available GitHub.","code":"install.packages('ecodive') install.packages('pak') pak::pak('cmmr/ecodive')"},{"path":"https://cmmr.github.io/ecodive/index.html","id":"usage","dir":"","previous_headings":"","what":"Usage","title":"Parallel and Memory-Efficient Ecological Diversity Metrics","text":"ecodive functions straightforward use. examples.","code":""},{"path":"https://cmmr.github.io/ecodive/index.html","id":"with-phyloseq-or-rbiom-objects","dir":"","previous_headings":"Usage","what":"With phyloseq or rbiom objects","title":"Parallel and Memory-Efficient Ecological Diversity Metrics","text":"easiest way use ecodive phyloseq rbiom object. objects conveniently bundle count data phylogenetic tree.","code":"library(ecodive) data(esophagus, package = 'phyloseq') data(hmp50,     package = 'rbiom')  # Calculate weighted UniFrac distance w_unifrac <- weighted_unifrac(esophagus) print(w_unifrac) #>           B         C #> C 0.1050480           #> D 0.1401124 0.1422409  # Calculate Faith's Phylogenetic Diversity faith_pd <- faith(hmp50) print(faith_pd[1:4]) #>   HMP01   HMP02   HMP03   HMP04  #> 6.22296 8.59432 8.93375 9.86597"},{"path":"https://cmmr.github.io/ecodive/index.html","id":"with-basic-r-objects","dir":"","previous_headings":"Usage","what":"With basic R objects","title":"Parallel and Memory-Efficient Ecological Diversity Metrics","text":"can also provide count data phylogenetic tree separate objects. ex_counts ex_tree objects included ecodive.","code":"## Example Data ---------------------- counts <- rarefy(ex_counts) counts[,1:4] #>        Streptococcus Bacteroides Corynebacterium Haemophilus #> Saliva           162           2               0         180 #> Gums             309           2               0          34 #> Nose               6           0             171           0 #> Stool              1         341               1           1   ## Alpha Diversity ------------------- shannon(counts) #>     Saliva       Gums       Nose      Stool  #> 0.74119910 0.35692121 1.10615349 0.07927797   faith(counts, tree = ex_tree) #> Saliva   Gums   Nose  Stool  #>    180    155    101    202    ## Beta Diversity -------------------- bray(counts) #>          Saliva      Gums      Nose #> Gums  0.4260870                     #> Nose  0.9797101 0.9826087           #> Stool 0.9884058 0.9884058 0.9913043  weighted_unifrac(counts, tree = ex_tree) #>          Saliva      Gums      Nose #> Gums   36.97681                     #> Nose   67.23768  55.97101           #> Stool 109.77971 109.44058 110.00870"},{"path":"https://cmmr.github.io/ecodive/index.html","id":"available-methods","dir":"","previous_headings":"","what":"Available Methods","title":"Parallel and Memory-Efficient Ecological Diversity Metrics","text":"Use list_metrics() browse metrics available calculating diversity.","code":"# Alpha Diversity list_metrics('alpha', 'id') #>  [1] \"ace\"         \"berger\"      \"brillouin\"   \"chao1\"       \"faith\"       #>  [6] \"fisher\"      \"simpson\"     \"inv_simpson\" \"margalef\"    \"mcintosh\"    #> [11] \"menhinick\"   \"observed\"    \"shannon\"     \"squares\"      # Beta Diversity list_metrics('beta', 'id') #>  [1] \"aitchison\"                 \"bhattacharyya\"             \"bray\"                      #>  [4] \"canberra\"                  \"chebyshev\"                 \"chord\"                     #>  [7] \"clark\"                     \"sorensen\"                  \"divergence\"                #> [10] \"euclidean\"                 \"generalized_unifrac\"       \"gower\"                     #> [13] \"hamming\"                   \"hellinger\"                 \"horn\"                      #> [16] \"jaccard\"                   \"jensen\"                    \"jsd\"                       #> [19] \"lorentzian\"                \"manhattan\"                 \"matusita\"                  #> [22] \"minkowski\"                 \"morisita\"                  \"motyka\"                    #> [25] \"normalized_unifrac\"        \"ochiai\"                    \"psym_chisq\"                #> [28] \"soergel\"                   \"squared_chisq\"             \"squared_chord\"             #> [31] \"squared_euclidean\"         \"topsoe\"                    \"unweighted_unifrac\"        #> [34] \"variance_adjusted_unifrac\" \"wave_hedges\"               \"weighted_unifrac\""},{"path":"https://cmmr.github.io/ecodive/index.html","id":"documentation","dir":"","previous_headings":"","what":"Documentation","title":"Parallel and Memory-Efficient Ecological Diversity Metrics","text":"online manual ecodive available https://cmmr.github.io/ecodive/. includes getting started guide, articles alpha/beta diversity, reference pages function.","code":""},{"path":"https://cmmr.github.io/ecodive/index.html","id":"automated-tests","dir":"","previous_headings":"","what":"Automated tests","title":"Parallel and Memory-Efficient Ecological Diversity Metrics","text":"following commands check ecodive passes bundled testing suite.","code":"install.packages('testthat') testthat::test_check('ecodive')"},{"path":[]},{"path":"https://cmmr.github.io/ecodive/index.html","id":"support","dir":"","previous_headings":"Community guidelines","what":"Support","title":"Parallel and Memory-Efficient Ecological Diversity Metrics","text":"Bug reports, feature requests, general questions can submitted https://github.com/cmmr/ecodive/issues.","code":""},{"path":"https://cmmr.github.io/ecodive/index.html","id":"contributing","dir":"","previous_headings":"Community guidelines","what":"Contributing","title":"Parallel and Memory-Efficient Ecological Diversity Metrics","text":"Pull requests welcome. Please ensure contributed code covered tests documentation (add additional tests documentation needed) passes automated tests. New functions must leverage C pthreads minimize memory CPU time. Please note ecodive project released Contributor Code Conduct. contributing project, agree abide terms.","code":""},{"path":"https://cmmr.github.io/ecodive/index.html","id":"license","dir":"","previous_headings":"","what":"License","title":"Parallel and Memory-Efficient Ecological Diversity Metrics","text":"MIT License © 2025 ecodive authors","code":""},{"path":"https://cmmr.github.io/ecodive/reference/adiv_functions.html","id":null,"dir":"Reference","previous_headings":"","what":"Alpha Diversity Metrics — adiv_functions","title":"Alpha Diversity Metrics — adiv_functions","text":"Alpha Diversity Metrics","code":""},{"path":"https://cmmr.github.io/ecodive/reference/adiv_functions.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Alpha Diversity Metrics — adiv_functions","text":"","code":"ace(counts, cutoff = 10, cpus = n_cpus())  berger(counts, norm = \"percent\", cpus = n_cpus())  brillouin(counts, cpus = n_cpus())  chao1(counts, cpus = n_cpus())  faith(counts, tree = NULL, cpus = n_cpus())  fisher(counts, digits = 3L, cpus = n_cpus())  inv_simpson(counts, norm = \"percent\", cpus = n_cpus())  margalef(counts, cpus = n_cpus())  mcintosh(counts, cpus = n_cpus())  menhinick(counts, cpus = n_cpus())  observed(counts, cpus = n_cpus())  shannon(counts, norm = \"percent\", cpus = n_cpus())  simpson(counts, norm = \"percent\", cpus = n_cpus())  squares(counts, cpus = n_cpus())"},{"path":"https://cmmr.github.io/ecodive/reference/adiv_functions.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Alpha Diversity Metrics — adiv_functions","text":"counts numeric matrix count data column feature, row sample. object coercible .matrix() can given , well phyloseq, rbiom, SummarizedExperiment, TreeSummarizedExperiment objects. cutoff maximum number observations consider \"rare\". Default: 10. cpus many parallel processing threads used. default, n_cpus(), use logical CPU cores. norm Normalize incoming counts. Options : norm = \"percent\" - Relative abundance (sample abundances sum 1). norm = \"binary\"  - Unweighted presence/absence (count either 0 1). norm = \"clr\"     - Centered log ratio. norm = \"none\"    - transformation. Default: 'percent', expected input formulas. tree phylo-class object representing phylogenetic tree OTUs counts. OTU identifiers given colnames(counts) must present tree. Can omitted tree embedded counts object attr(counts, 'tree'). digits Precision returned values, number decimal places. E.g. default digits=3 return 6.392.","code":""},{"path":"https://cmmr.github.io/ecodive/reference/adiv_functions.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Alpha Diversity Metrics — adiv_functions","text":"numeric vector.","code":""},{"path":"https://cmmr.github.io/ecodive/reference/adiv_functions.html","id":"formulas","dir":"Reference","previous_headings":"","what":"Formulas","title":"Alpha Diversity Metrics — adiv_functions","text":"Prerequisite: counts whole numbers. Given: \\(n\\) : number features (e.g. species, OTUs, ASVs, etc). \\(X_i\\) : Integer count \\(\\)-th feature. \\(X_T\\) : Total counts (.e. sequencing depth). \\(X_T = \\sum_{=1}^{n} X_i\\) \\(P_i\\) : Proportional abundance \\(\\)-th feature. \\(P_i = X_i / X_T\\) \\(F_1\\) : Number features \\(X_i = 1\\) (.e. singletons). \\(F_2\\) : Number features \\(X_i = 2\\) (.e. doubletons).","code":""},{"path":"https://cmmr.github.io/ecodive/reference/adiv_functions.html","id":"abundance-based-coverage-estimator-ace-","dir":"Reference","previous_headings":"","what":"Abundance-based Coverage Estimator (ACE)","title":"Alpha Diversity Metrics — adiv_functions","text":"Given: \\(n\\) : number features (e.g. species, OTUs, ASVs, etc). \\(r\\) : Rare cutoff. Features \\(\\le r\\) counts considered rare. \\(X_i\\) : Integer count \\(\\)-th feature. \\(F_i\\) : Number features exactly \\(\\) counts. \\(F_1\\) : Number features \\(X_i = 1\\) (.e. singletons). \\(F_{rare}\\) : Number rare features \\(X_i \\le r\\). \\(F_{abund}\\) : Number abundant features \\(X_i > r\\). \\(X_{rare}\\) : Total counts belonging rare features. \\(C_{ace}\\) : sample abundance coverage estimator, defined . \\(\\gamma_{ace}^2\\) : estimated coefficient variation, defined . \\(D_{ace}\\) : Estimated number features sample. \\(\\displaystyle C_{ace} = 1 - \\frac{F_1}{X_{rare}}\\) \\(\\displaystyle \\gamma_{ace}^2 = \\max\\left[\\frac{F_{rare} \\sum_{=1}^{r}(-1)F_i}{C_{ace}X_{rare}(X_{rare} - 1)} - 1, 0\\right]\\) \\(\\displaystyle D_{ace} = F_{abund} + \\frac{F_{rare}}{C_{ace}} + \\frac{F_1}{C_{ace}}\\gamma_{ace}^2 \\)","code":""},{"path":"https://cmmr.github.io/ecodive/reference/adiv_functions.html","id":"faith-s-phylogenetic-diversity-faith-s-pd-","dir":"Reference","previous_headings":"","what":"Faith's Phylogenetic Diversity (Faith's PD)","title":"Alpha Diversity Metrics — adiv_functions","text":"Given \\(n\\) branches lengths \\(L\\) sample's abundances \\(\\) branches coded 1 present 0 absent: \\(\\sum_{= 1}^{n} L_i A_i\\)","code":""},{"path":"https://cmmr.github.io/ecodive/reference/adiv_functions.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Alpha Diversity Metrics — adiv_functions","text":"","code":"# Example counts matrix     t(ex_counts) #>                   Saliva Gums Nose Stool #> Streptococcus        162  793   22     1 #> Bacteroides            2    4    2   611 #> Corynebacterium        0    0  498     1 #> Haemophilus          180   87    2     1 #> Propionibacterium      1    1  251     0 #> Staphylococcus         0    1  236     1          ace(ex_counts) #> Saliva   Gums   Nose  Stool  #>    5.0    8.9    6.0    NaN           chao1(ex_counts) #> Saliva   Gums   Nose  Stool  #>    4.5    Inf    6.0    Inf           squares(ex_counts) #>    Saliva      Gums      Nose     Stool  #>  4.492762  8.243044  6.000000 20.793551"},{"path":"https://cmmr.github.io/ecodive/reference/alpha_div.html","id":null,"dir":"Reference","previous_headings":"","what":"Alpha Diversity Wrapper Function — alpha_div","title":"Alpha Diversity Wrapper Function — alpha_div","text":"Alpha Diversity Wrapper Function","code":""},{"path":"https://cmmr.github.io/ecodive/reference/alpha_div.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Alpha Diversity Wrapper Function — alpha_div","text":"","code":"alpha_div(   counts,   metric,   norm = \"percent\",   cutoff = 10,   digits = 3L,   tree = NULL,   cpus = n_cpus() )"},{"path":"https://cmmr.github.io/ecodive/reference/alpha_div.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Alpha Diversity Wrapper Function — alpha_div","text":"counts numeric matrix count data column feature, row sample. object coercible .matrix() can given , well phyloseq, rbiom, SummarizedExperiment, TreeSummarizedExperiment objects. metric name alpha diversity metric. One c('ace', 'berger', 'brillouin', 'chao1', 'faith', 'fisher', 'inv_simpson', 'margalef', 'mcintosh', 'menhinick', 'observed', 'shannon', 'simpson', 'squares'). Case-insensitive partial name matching supported. Programmatic access via list_metrics('alpha'). norm Normalize incoming counts. Options : norm = \"percent\" - Relative abundance (sample abundances sum 1). norm = \"binary\"  - Unweighted presence/absence (count either 0 1). norm = \"clr\"     - Centered log ratio. norm = \"none\"    - transformation. Default: 'percent', expected input formulas. cutoff maximum number observations consider \"rare\". Default: 10. digits Precision returned values, number decimal places. E.g. default digits=3 return 6.392. tree phylo-class object representing phylogenetic tree OTUs counts. OTU identifiers given colnames(counts) must present tree. Can omitted tree embedded counts object attr(counts, 'tree'). cpus many parallel processing threads used. default, n_cpus(), use logical CPU cores.","code":""},{"path":"https://cmmr.github.io/ecodive/reference/alpha_div.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Alpha Diversity Wrapper Function — alpha_div","text":"numeric vector.","code":""},{"path":[]},{"path":"https://cmmr.github.io/ecodive/reference/alpha_div.html","id":"integer-count-requirements","dir":"Reference","previous_headings":"","what":"Integer Count Requirements","title":"Alpha Diversity Wrapper Function — alpha_div","text":"frequent critical error alpha diversity analysis providing wrong type data metric's formula. indices mathematically defined based counts individuals require raw, integer abundance data. Others based proportional abundances can accept either integer counts (converted proportions) pre-normalized proportional data. Using proportional data metric requires integer counts return error message.","code":""},{"path":"https://cmmr.github.io/ecodive/reference/alpha_div.html","id":"requires-integer-counts-only","dir":"Reference","previous_headings":"","what":"Requires Integer Counts Only","title":"Alpha Diversity Wrapper Function — alpha_div","text":"Chao1 ACE Squares Richness Estimator Margalef's Index Menhinick's Index Fisher's Alpha Brillouin Index","code":""},{"path":"https://cmmr.github.io/ecodive/reference/alpha_div.html","id":"can-use-proportional-data","dir":"Reference","previous_headings":"","what":"Can Use Proportional Data","title":"Alpha Diversity Wrapper Function — alpha_div","text":"Observed Features Shannon Index Gini-Simpson Index Inverse Simpson Index Berger-Parker Index McIntosh Index Faith's PD","code":""},{"path":"https://cmmr.github.io/ecodive/reference/alpha_div.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Alpha Diversity Wrapper Function — alpha_div","text":"","code":"# Example counts matrix     ex_counts #>        Streptococcus Bacteroides Corynebacterium Haemophilus Propionibacterium #> Saliva           162           2               0         180                 1 #> Gums             793           4               0          87                 1 #> Nose              22           2             498           2               251 #> Stool              1         611               1           1                 0 #>        Staphylococcus #> Saliva              0 #> Gums                1 #> Nose              236 #> Stool               1          # Shannon diversity values     alpha_div(ex_counts, 'Shannon') #>     Saliva       Gums       Nose      Stool  #> 0.74119910 0.36684449 1.14222899 0.04824952           # Chao1 diversity values     alpha_div(ex_counts, 'c') #> Saliva   Gums   Nose  Stool  #>    4.5    Inf    6.0    Inf           # Faith PD values     alpha_div(ex_counts, 'faith', tree = ex_tree) #> Saliva   Gums   Nose  Stool  #>    180    191    215    202"},{"path":"https://cmmr.github.io/ecodive/reference/bdiv_functions.html","id":null,"dir":"Reference","previous_headings":"","what":"Beta Diversity Metrics — bdiv_functions","title":"Beta Diversity Metrics — bdiv_functions","text":"Beta Diversity Metrics","code":""},{"path":"https://cmmr.github.io/ecodive/reference/bdiv_functions.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Beta Diversity Metrics — bdiv_functions","text":"","code":"aitchison(counts, pseudocount = NULL, pairs = NULL, cpus = n_cpus())  bhattacharyya(counts, norm = \"percent\", pairs = NULL, cpus = n_cpus())  bray(counts, norm = \"percent\", pairs = NULL, cpus = n_cpus())  canberra(counts, norm = \"percent\", pairs = NULL, cpus = n_cpus())  chebyshev(counts, norm = \"percent\", pairs = NULL, cpus = n_cpus())  chord(counts, pairs = NULL, cpus = n_cpus())  clark(counts, norm = \"percent\", pairs = NULL, cpus = n_cpus())  divergence(counts, norm = \"percent\", pairs = NULL, cpus = n_cpus())  euclidean(counts, norm = \"percent\", pairs = NULL, cpus = n_cpus())  gower(counts, norm = \"percent\", pairs = NULL, cpus = n_cpus())  hellinger(counts, norm = \"percent\", pairs = NULL, cpus = n_cpus())  horn(counts, norm = \"percent\", pairs = NULL, cpus = n_cpus())  jensen(counts, norm = \"percent\", pairs = NULL, cpus = n_cpus())  jsd(counts, norm = \"percent\", pairs = NULL, cpus = n_cpus())  lorentzian(counts, norm = \"percent\", pairs = NULL, cpus = n_cpus())  manhattan(counts, norm = \"percent\", pairs = NULL, cpus = n_cpus())  matusita(counts, norm = \"percent\", pairs = NULL, cpus = n_cpus())  minkowski(counts, norm = \"percent\", power = 1.5, pairs = NULL, cpus = n_cpus())  morisita(counts, pairs = NULL, cpus = n_cpus())  motyka(counts, norm = \"percent\", pairs = NULL, cpus = n_cpus())  psym_chisq(counts, norm = \"percent\", pairs = NULL, cpus = n_cpus())  soergel(counts, norm = \"percent\", pairs = NULL, cpus = n_cpus())  squared_chisq(counts, norm = \"percent\", pairs = NULL, cpus = n_cpus())  squared_chord(counts, norm = \"percent\", pairs = NULL, cpus = n_cpus())  squared_euclidean(counts, norm = \"percent\", pairs = NULL, cpus = n_cpus())  topsoe(counts, norm = \"percent\", pairs = NULL, cpus = n_cpus())  wave_hedges(counts, norm = \"percent\", pairs = NULL, cpus = n_cpus())  hamming(counts, pairs = NULL, cpus = n_cpus())  jaccard(counts, pairs = NULL, cpus = n_cpus())  ochiai(counts, pairs = NULL, cpus = n_cpus())  sorensen(counts, pairs = NULL, cpus = n_cpus())  unweighted_unifrac(counts, tree = NULL, pairs = NULL, cpus = n_cpus())  weighted_unifrac(counts, tree = NULL, pairs = NULL, cpus = n_cpus())  normalized_unifrac(counts, tree = NULL, pairs = NULL, cpus = n_cpus())  generalized_unifrac(   counts,   tree = NULL,   alpha = 0.5,   pairs = NULL,   cpus = n_cpus() )  variance_adjusted_unifrac(counts, tree = NULL, pairs = NULL, cpus = n_cpus())"},{"path":"https://cmmr.github.io/ecodive/reference/bdiv_functions.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Beta Diversity Metrics — bdiv_functions","text":"counts numeric matrix count data column feature, row sample. object coercible .matrix() can given , well phyloseq, rbiom, SummarizedExperiment, TreeSummarizedExperiment objects. pseudocount value add counts counts prevent taking log(0) unobserved features. default, NULL, selects smallest non-zero value counts. pairs combinations samples distances calculated ? default value (NULL) calculates -vs-. Provide numeric logical vector specifying positions distance matrix calculate. See examples. cpus many parallel processing threads used. default, n_cpus(), use logical CPU cores. norm Normalize incoming counts. Options : norm = \"percent\" - Relative abundance (sample abundances sum 1). norm = \"binary\"  - Unweighted presence/absence (count either 0 1). norm = \"clr\"     - Centered log ratio. norm = \"none\"    - transformation. Default: 'percent', expected input formulas. power Scaling factor magnitude differences communities (\\(p\\)). Default: 1.5 tree phylo-class object representing phylogenetic tree OTUs counts. OTU identifiers given colnames(counts) must present tree. Can omitted tree embedded counts object attr(counts, 'tree'). alpha much weight give relative abundances; value 0 1, inclusive. Setting alpha=1 equivalent normalized_unifrac().","code":""},{"path":"https://cmmr.github.io/ecodive/reference/bdiv_functions.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Beta Diversity Metrics — bdiv_functions","text":"dist object.","code":""},{"path":"https://cmmr.github.io/ecodive/reference/bdiv_functions.html","id":"formulas","dir":"Reference","previous_headings":"","what":"Formulas","title":"Beta Diversity Metrics — bdiv_functions","text":"Given: \\(n\\) : number features. \\(X_i\\), \\(Y_i\\) : Absolute counts \\(\\)-th feature samples \\(X\\) \\(Y\\). \\(X_T\\), \\(Y_T\\) : Total counts sample. \\(X_T = \\sum_{=1}^{n} X_i\\) \\(P_i\\), \\(Q_i\\) : Proportional abundances \\(X_i\\) \\(Y_i\\). \\(P_i = X_i / X_T\\) \\(X_L\\), \\(Y_L\\) : Mean log abundances. \\(X_L = \\frac{1}{n}\\sum_{=1}^{n} \\ln{X_i}\\) \\(R_i\\) : range \\(\\)-th feature across samples (max - min).","code":""},{"path":"https://cmmr.github.io/ecodive/reference/bdiv_functions.html","id":"presence-absence","dir":"Reference","previous_headings":"","what":"Presence / Absence","title":"Beta Diversity Metrics — bdiv_functions","text":"Given: \\(\\), \\(B\\) : Number features sample. \\(J\\) : Number features common.","code":""},{"path":"https://cmmr.github.io/ecodive/reference/bdiv_functions.html","id":"phylogenetic","dir":"Reference","previous_headings":"","what":"Phylogenetic","title":"Beta Diversity Metrics — bdiv_functions","text":"Given \\(n\\) branches lengths \\(L\\) pair samples' binary (\\(\\) \\(B\\)) proportional abundances (\\(P\\) \\(Q\\)) branches. See vignette('unifrac') detailed example UniFrac calculations.","code":""},{"path":"https://cmmr.github.io/ecodive/reference/bdiv_functions.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Beta Diversity Metrics — bdiv_functions","text":"Levy, ., Shalom, B. R., & Chalamish, M. (2024). guide similarity measures. arXiv. Cha, S.-H. (2007). Comprehensive survey distance/similarity measures probability density functions. International Journal Mathematical Models Methods Applied Sciences, 1(4), 300–307.","code":""},{"path":"https://cmmr.github.io/ecodive/reference/bdiv_functions.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Beta Diversity Metrics — bdiv_functions","text":"","code":"# Example counts matrix     t(ex_counts) #>                   Saliva Gums Nose Stool #> Streptococcus        162  793   22     1 #> Bacteroides            2    4    2   611 #> Corynebacterium        0    0  498     1 #> Haemophilus          180   87    2     1 #> Propionibacterium      1    1  251     0 #> Staphylococcus         0    1  236     1          bray(ex_counts) #>          Saliva      Gums      Nose #> Gums  0.4265973                     #> Nose  0.9713843 0.9720256           #> Stool 0.9909509 0.9911046 0.9915177          jaccard(ex_counts) #>          Saliva      Gums      Nose #> Gums  0.2000000                     #> Nose  0.3333333 0.1666667           #> Stool 0.5000000 0.3333333 0.1666667          generalized_unifrac(ex_counts, tree = ex_tree) #>          Saliva      Gums      Nose #> Gums  0.4471644                     #> Nose  0.8215129 0.7607876           #> Stool 0.9727827 0.9784242 0.9730332          # Only calculate distances for Saliva vs all.     bray(ex_counts, pairs = 1:3) #>          Saliva      Gums      Nose #> Gums  0.4265973                     #> Nose  0.9713843        NA           #> Stool 0.9909509        NA        NA"},{"path":"https://cmmr.github.io/ecodive/reference/beta_div.html","id":null,"dir":"Reference","previous_headings":"","what":"Beta Diversity Wrapper Function — beta_div","title":"Beta Diversity Wrapper Function — beta_div","text":"Beta Diversity Wrapper Function","code":""},{"path":"https://cmmr.github.io/ecodive/reference/beta_div.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Beta Diversity Wrapper Function — beta_div","text":"","code":"beta_div(   counts,   metric,   norm = \"percent\",   power = 1.5,   pseudocount = NULL,   alpha = 0.5,   tree = NULL,   pairs = NULL,   cpus = n_cpus() )"},{"path":"https://cmmr.github.io/ecodive/reference/beta_div.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Beta Diversity Wrapper Function — beta_div","text":"counts numeric matrix count data column feature, row sample. object coercible .matrix() can given , well phyloseq, rbiom, SummarizedExperiment, TreeSummarizedExperiment objects. metric name beta diversity metric. One c('aitchison', 'bhattacharyya', 'bray', 'canberra', 'chebyshev', 'chord', 'clark', 'divergence', 'euclidean', 'generalized_unifrac', 'gower', 'hamming', 'hellinger', 'horn', 'jaccard', 'jensen', 'jsd', 'lorentzian', 'manhattan', 'matusita', 'minkowski', 'morisita', 'motyka', 'normalized_unifrac', 'ochiai', 'psym_chisq', 'soergel', 'sorensen', 'squared_chisq', 'squared_chord', 'squared_euclidean', 'topsoe', 'unweighted_unifrac', 'variance_adjusted_unifrac', 'wave_hedges', 'weighted_unifrac'). Flexible matching supported (see ). Programmatic access via list_metrics('beta'). norm Normalize incoming counts. Options : norm = \"percent\" - Relative abundance (sample abundances sum 1). norm = \"binary\"  - Unweighted presence/absence (count either 0 1). norm = \"clr\"     - Centered log ratio. norm = \"none\"    - transformation. Default: 'percent', expected input formulas. power Scaling factor magnitude differences communities (\\(p\\)). Default: 1.5 pseudocount value add counts counts prevent taking log(0) unobserved features. default, NULL, selects smallest non-zero value counts. alpha much weight give relative abundances; value 0 1, inclusive. Setting alpha=1 equivalent normalized_unifrac(). tree phylo-class object representing phylogenetic tree OTUs counts. OTU identifiers given colnames(counts) must present tree. Can omitted tree embedded counts object attr(counts, 'tree'). pairs combinations samples distances calculated ? default value (NULL) calculates -vs-. Provide numeric logical vector specifying positions distance matrix calculate. See examples. cpus many parallel processing threads used. default, n_cpus(), use logical CPU cores.","code":""},{"path":"https://cmmr.github.io/ecodive/reference/beta_div.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Beta Diversity Wrapper Function — beta_div","text":"numeric vector.","code":""},{"path":"https://cmmr.github.io/ecodive/reference/beta_div.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Beta Diversity Wrapper Function — beta_div","text":"List Beta Diversity Metrics Flexible name matching Case insensitive partial matching. runs non-alpha characters converted underscores. E.g. metric = 'Weighted UniFrac selects weighted_unifrac. UniFrac names can shortened first letter plus \"unifrac\". E.g. uunifrac, w_unifrac, V UniFrac. also support partial matching. Finished code always use full primary option name avoid ambiguity future additions metrics list.","code":""},{"path":"https://cmmr.github.io/ecodive/reference/beta_div.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Beta Diversity Wrapper Function — beta_div","text":"","code":"# Example counts matrix     ex_counts #>        Streptococcus Bacteroides Corynebacterium Haemophilus Propionibacterium #> Saliva           162           2               0         180                 1 #> Gums             793           4               0          87                 1 #> Nose              22           2             498           2               251 #> Stool              1         611               1           1                 0 #>        Staphylococcus #> Saliva              0 #> Gums                1 #> Nose              236 #> Stool               1          # Bray-Curtis distances     beta_div(ex_counts, 'bray') #>          Saliva      Gums      Nose #> Gums  0.4265973                     #> Nose  0.9713843 0.9720256           #> Stool 0.9909509 0.9911046 0.9915177          # Generalized UniFrac distances     beta_div(ex_counts, 'GUniFrac', tree = ex_tree) #>          Saliva      Gums      Nose #> Gums  0.4471644                     #> Nose  0.8215129 0.7607876           #> Stool 0.9727827 0.9784242 0.9730332"},{"path":"https://cmmr.github.io/ecodive/reference/documentation.html","id":null,"dir":"Reference","previous_headings":"","what":"documentation — documentation","title":"documentation — documentation","text":"documentation","code":""},{"path":"https://cmmr.github.io/ecodive/reference/documentation.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"documentation — documentation","text":"alpha much weight give relative abundances; value 0 1, inclusive. Setting alpha=1 equivalent normalized_unifrac(). counts numeric matrix count data column feature, row sample. object coercible .matrix() can given , well phyloseq, rbiom, SummarizedExperiment, TreeSummarizedExperiment objects. cpus many parallel processing threads used. default, n_cpus(), use logical CPU cores. cutoff maximum number observations consider \"rare\". Default: 10. digits Precision returned values, number decimal places. E.g. default digits=3 return 6.392. pairs combinations samples distances calculated ? default value (NULL) calculates -vs-. Provide numeric logical vector specifying positions distance matrix calculate. See examples. power Scaling factor magnitude differences communities (\\(p\\)). Default: 1.5 pseudocount value add counts counts prevent taking log(0) unobserved features. default, NULL, selects smallest non-zero value counts. norm Normalize incoming counts. Options : norm = \"percent\" - Relative abundance (sample abundances sum 1). norm = \"binary\"  - Unweighted presence/absence (count either 0 1). norm = \"clr\"     - Centered log ratio. norm = \"none\"    - transformation. Default: 'percent', expected input formulas. tree phylo-class object representing phylogenetic tree OTUs counts. OTU identifiers given colnames(counts) must present tree. Can omitted tree embedded counts object attr(counts, 'tree').","code":""},{"path":"https://cmmr.github.io/ecodive/reference/ex_counts.html","id":null,"dir":"Reference","previous_headings":"","what":"Example counts matrix — ex_counts","title":"Example counts matrix — ex_counts","text":"Genera found four human body sites.","code":""},{"path":"https://cmmr.github.io/ecodive/reference/ex_counts.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Example counts matrix — ex_counts","text":"","code":"ex_counts"},{"path":"https://cmmr.github.io/ecodive/reference/ex_counts.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Example counts matrix — ex_counts","text":"matrix 4 samples (columns) x 6 genera (rows).","code":""},{"path":"https://cmmr.github.io/ecodive/reference/ex_counts.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Example counts matrix — ex_counts","text":"Derived Human Microbiome Project dataset. https://commonfund.nih.gov/hmp","code":""},{"path":"https://cmmr.github.io/ecodive/reference/ex_tree.html","id":null,"dir":"Reference","previous_headings":"","what":"Example phylogenetic tree — ex_tree","title":"Example phylogenetic tree — ex_tree","text":"Companion tree ex_counts.","code":""},{"path":"https://cmmr.github.io/ecodive/reference/ex_tree.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Example phylogenetic tree — ex_tree","text":"","code":"ex_tree"},{"path":"https://cmmr.github.io/ecodive/reference/ex_tree.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Example phylogenetic tree — ex_tree","text":"phylo object.","code":""},{"path":"https://cmmr.github.io/ecodive/reference/ex_tree.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Example phylogenetic tree — ex_tree","text":"ex_tree encodes tree structure:","code":"+----------44---------- Haemophilus   +-2-|   |   +----------------68---------------- Bacteroides   |   |             +---18---- Streptococcus   |      +--12--|   |      |      +--11-- Staphylococcus   +--11--|          |      +-----24----- Corynebacterium          +--12--|                 +--13-- Propionibacterium"},{"path":"https://cmmr.github.io/ecodive/reference/metrics.html","id":null,"dir":"Reference","previous_headings":"","what":"Find and Browse Available Metrics — list_metrics","title":"Find and Browse Available Metrics — list_metrics","text":"Programmatic access lists available metrics, associated functions.","code":""},{"path":"https://cmmr.github.io/ecodive/reference/metrics.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find and Browse Available Metrics — list_metrics","text":"","code":"list_metrics(   div = c(NA, \"alpha\", \"beta\"),   val = c(\"data.frame\", \"list\", \"func\", \"id\", \"name\", \"div\", \"phylo\", \"weighted\",     \"int_only\", \"true_metric\"),   nm = c(NA, \"id\", \"name\"),   phylo = NULL,   weighted = NULL,   int_only = NULL,   true_metric = NULL )  match_metric(   metric,   div = NULL,   phylo = NULL,   weighted = NULL,   int_only = NULL,   true_metric = NULL )"},{"path":"https://cmmr.github.io/ecodive/reference/metrics.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find and Browse Available Metrics — list_metrics","text":"div, phylo, weighted, int_only, true_metric Consider metrics matching specific criteria. example, div = \"alpha\" return alpha diversity metrics. Default: NULL val Sets return value function call. See \"Value\" section . Default: \"data.frame\" nm value use names returned object. Default \"id\" val \"list\" \"func\", otherwise default NA (name). metric name alpha/beta diversity metric search . Supports partial matching. non-alpha characters ignored.","code":""},{"path":"https://cmmr.github.io/ecodive/reference/metrics.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Find and Browse Available Metrics — list_metrics","text":"match_metric() list following elements. name : Metric name, e.g. \"Faith's Phylogenetic Diversity\" id : Metric ID - also name function, e.g. \"faith\" div : Either \"alpha\" \"beta\". phylo : TRUE metric requires phylogenetic tree; FALSE otherwise. weighted : TRUE metric takes relative abundance account; FALSE uses presence/absence. int_only : TRUE metric requires integer counts; FALSE otherwise. true_metric : TRUE metric true metric satisfies triangle inequality; FALSE non-metric dissimilarity; NA alpha diversity metrics. func : function metric, e.g. ecodive::faith params : Formal args func, e.g. c(\"counts\", \"tree\", \"cpus\") list_metrics() returned object's type values controlled val nm arguments. val = \"data.frame\" : data.frame options sourced. val = \"list\" : list objects returned match_metric() (). val = \"func\" : list functions. val = \"id\" : character vector metric IDs. val = \"name\" : character vector metric names. val = \"div\" : character vector \"alpha\" /\"beta\". val = \"phylo\" : logical vector indicating metrics require tree. val = \"weighted\" : logical vector indicating metrics take relative abundance account (opposed just presence/absence). val = \"int_only\" : logical vector indicating metrics require integer counts. val = \"true_metric\" : logical vector indicating metrics true metrics satisfy triangle inequality, work better ordinations PCoA. nm set, names vector list metric ID (nm=\"id\") name (nm=\"name\"). val=\"data.frame\", names applied rownames() property data.table.","code":""},{"path":"https://cmmr.github.io/ecodive/reference/metrics.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Find and Browse Available Metrics — list_metrics","text":"","code":"# A data.frame of all available metrics.     head(list_metrics()) #>                                       name            id phylo weighted #> 1 Abundance-based Coverage Estimator (ACE)           ace FALSE     TRUE #> 2                       Aitchison Distance     aitchison FALSE     TRUE #> 3                      Berger-Parker Index        berger FALSE     TRUE #> 4                   Bhattacharyya Distance bhattacharyya FALSE     TRUE #> 5                Bray-Curtis Dissimilarity          bray FALSE     TRUE #> 6                          Brillouin Index     brillouin FALSE     TRUE #>   int_only true_metric   div #> 1     TRUE          NA alpha #> 2    FALSE        TRUE  beta #> 3    FALSE          NA alpha #> 4    FALSE        TRUE  beta #> 5    FALSE       FALSE  beta #> 6     TRUE          NA alpha          # All alpha diversity function names.     list_metrics('alpha', val = 'id') #>  [1] \"ace\"         \"berger\"      \"brillouin\"   \"chao1\"       \"faith\"       #>  [6] \"fisher\"      \"simpson\"     \"inv_simpson\" \"margalef\"    \"mcintosh\"    #> [11] \"menhinick\"   \"observed\"    \"shannon\"     \"squares\"              # Try to find a metric named 'otus'.     m <- match_metric('otus')          # The result is a list that includes the function.     str(m) #> List of 9 #>  $ name       : chr \"Observed Features\" #>  $ id         : chr \"observed\" #>  $ phylo      : logi FALSE #>  $ weighted   : logi FALSE #>  $ int_only   : logi FALSE #>  $ true_metric: logi NA #>  $ div        : chr \"alpha\" #>  $ func       :function (counts, cpus = n_cpus())   #>  $ params     : chr [1:2] \"counts\" \"cpus\""},{"path":"https://cmmr.github.io/ecodive/reference/n_cpus.html","id":null,"dir":"Reference","previous_headings":"","what":"Number of CPU Cores — n_cpus","title":"Number of CPU Cores — n_cpus","text":"thin wrapper around parallely::availableCores(). parallely package installed, falls back parallel::detectCores(.tests = TRUE, logical = TRUE). Returns 1 pthread support unavailable number cpus determined.","code":""},{"path":"https://cmmr.github.io/ecodive/reference/n_cpus.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Number of CPU Cores — n_cpus","text":"","code":"n_cpus()"},{"path":"https://cmmr.github.io/ecodive/reference/n_cpus.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Number of CPU Cores — n_cpus","text":"scalar integer, guaranteed least 1.","code":""},{"path":"https://cmmr.github.io/ecodive/reference/n_cpus.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Number of CPU Cores — n_cpus","text":"","code":"n_cpus() #> [1] 4"},{"path":"https://cmmr.github.io/ecodive/reference/rarefy.html","id":null,"dir":"Reference","previous_headings":"","what":"Rarefy OTU counts. — rarefy","title":"Rarefy OTU counts. — rarefy","text":"Sub-sample OTU observations samples equal number. called data non-integer abundances, values re-scaled integers 1 depth sum depth.","code":""},{"path":"https://cmmr.github.io/ecodive/reference/rarefy.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Rarefy OTU counts. — rarefy","text":"","code":"rarefy(   counts,   depth = 0.1,   n_samples = NULL,   seed = 0,   times = NULL,   cpus = n_cpus() )"},{"path":"https://cmmr.github.io/ecodive/reference/rarefy.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Rarefy OTU counts. — rarefy","text":"counts numeric matrix count data column feature, row sample. object coercible .matrix() can given , well phyloseq, rbiom, SummarizedExperiment, TreeSummarizedExperiment objects. depth many observations keep per sample. 0 < depth < 1, taken minimum percentage dataset's observations keep. Ignored n_samples specified. Default: 0.1 n_samples number samples keep. 0 < n_samples < 1, taken percentage samples keep. negative, number samples dropped. 0, samples kept. NULL, depth used instead. Default: NULL seed integer seed randomizing observations keep drop. need create different random rarefactions data, set seed different number time. times many independent rarefactions perform. set, rarefy() return list matrices. seeds matrix sequential, starting seed. cpus many parallel processing threads used. default, n_cpus(), use logical CPU cores.","code":""},{"path":"https://cmmr.github.io/ecodive/reference/rarefy.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Rarefy OTU counts. — rarefy","text":"integer matrix.","code":""},{"path":"https://cmmr.github.io/ecodive/reference/rarefy.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Rarefy OTU counts. — rarefy","text":"","code":"# Create an OTU matrix with 4 samples (A-D) and 5 OTUs.     counts <- matrix(       data     = c(4,0,3,2,6,0,8,0,0,5,0,9,0,0,7,0,10,0,0,1),       nrow     = 5,       dimnames = list(paste0('OTU', 1:5), LETTERS[1:4]) )     counts #>      A B C  D #> OTU1 4 0 0  0 #> OTU2 0 8 9 10 #> OTU3 3 0 0  0 #> OTU4 2 0 0  0 #> OTU5 6 5 7  1     colSums(counts) #>  A  B  C  D  #> 15 13 16 11           counts <- rarefy(counts, depth = 14)     counts #>      A B C D #> OTU1 0 0 0 0 #> OTU2 0 5 5 4 #> OTU3 0 0 0 0 #> OTU4 0 0 0 0 #> OTU5 4 2 7 1     colSums(counts) #>  A  B  C  D  #>  4  7 12  5"},{"path":"https://cmmr.github.io/ecodive/reference/read_tree.html","id":null,"dir":"Reference","previous_headings":"","what":"Read a newick formatted phylogenetic tree. — read_tree","title":"Read a newick formatted phylogenetic tree. — read_tree","text":"phylogenetic tree required computing UniFrac distance matrices. can load tree file providing tree string directly. tree must Newick format, also known parenthetic format New Hampshire format.","code":""},{"path":"https://cmmr.github.io/ecodive/reference/read_tree.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Read a newick formatted phylogenetic tree. — read_tree","text":"","code":"read_tree(newick, underscores = FALSE)"},{"path":"https://cmmr.github.io/ecodive/reference/read_tree.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Read a newick formatted phylogenetic tree. — read_tree","text":"newick Input data either file path, URL, Newick string. Compressed (gzip bzip2) files also supported. underscores TRUE, underscores unquoted names remain underscores. FALSE, underscores unquoted named converted spaces.","code":""},{"path":"https://cmmr.github.io/ecodive/reference/read_tree.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Read a newick formatted phylogenetic tree. — read_tree","text":"phylo class object representing tree.","code":""},{"path":"https://cmmr.github.io/ecodive/reference/read_tree.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Read a newick formatted phylogenetic tree. — read_tree","text":"","code":"tree <- read_tree(\"         (A:0.99,((B:0.87,C:0.89):0.51,(((D:0.16,(E:0.83,F:0.96)         :0.94):0.69,(G:0.92,(H:0.62,I:0.85):0.54):0.23):0.74,J:0.1         2):0.43):0.67);\")     class(tree) #> [1] \"phylo\""},{"path":[]},{"path":"https://cmmr.github.io/ecodive/news/index.html","id":"breaking-changes-2-1-0","dir":"Changelog","previous_headings":"","what":"Breaking Changes","title":"ecodive 2.1.0","text":"rescale parameter superseded norm parameter.","code":""},{"path":"https://cmmr.github.io/ecodive/news/index.html","id":"fixes-2-1-0","dir":"Changelog","previous_headings":"","what":"Fixes","title":"ecodive 2.1.0","text":"alpha_div() beta_div() forward applicable parameters. longer crashes pairs = integer(0). pseudocount = NULL correctly selects smallest non-zero count.","code":""},{"path":"https://cmmr.github.io/ecodive/news/index.html","id":"ecodive-200","dir":"Changelog","previous_headings":"","what":"ecodive 2.0.0","title":"ecodive 2.0.0","text":"CRAN release: 2025-09-21","code":""},{"path":"https://cmmr.github.io/ecodive/news/index.html","id":"breaking-changes-2-0-0","dir":"Changelog","previous_headings":"","what":"Breaking Changes","title":"ecodive 2.0.0","text":"Input matrix now samples rows. Removed weighted parameter.","code":""},{"path":"https://cmmr.github.io/ecodive/news/index.html","id":"added-new-diversity-methods-2-0-0","dir":"Changelog","previous_headings":"","what":"Added New Diversity Methods","title":"ecodive 2.0.0","text":"Updated Alpha Options: c(\"ace\", \"berger\", \"brillouin\", \"chao1\", \"faith\", \"fisher\", \"simpson\", \"inv_simpson\", \"margalef\", \"mcintosh\", \"menhinick\", \"observed\", \"shannon\", \"squares\") Updated Beta Options: c(\"aitchison\", \"bhattacharyya\", \"bray\", \"canberra\", \"chebyshev\", \"chord\", \"clark\", \"sorensen\", \"divergence\", \"euclidean\", \"generalized_unifrac\", \"gower\", \"hamming\", \"hellinger\", \"horn\", \"jaccard\", \"jensen\", \"jsd\", \"lorentzian\", \"manhattan\", \"matusita\", \"minkowski\", \"morisita\", \"motyka\", \"normalized_unifrac\", \"ochiai\", \"psym_chisq\", \"soergel\", \"squared_chisq\", \"squared_chord\", \"squared_euclidean\", \"topsoe\", \"unweighted_unifrac\", \"variance_adjusted_unifrac\", \"wave_hedges\", \"weighted_unifrac\")","code":""},{"path":"https://cmmr.github.io/ecodive/news/index.html","id":"ecodive-100","dir":"Changelog","previous_headings":"","what":"ecodive 1.0.0","title":"ecodive 1.0.0","text":"CRAN release: 2025-08-22 first release ecodive.","code":""}]
